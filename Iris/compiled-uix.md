# Compiled UIX
Compiled UIX (often shortened to "UIB" for "UI Binary") is one of two formats used by Iris 3.0+ for defining user interfaces. UIB is generated by passing one or more UIX XML files to the UIX compiler. The UI definition is pre-processed into custom bytecode alongside a slew of data tables. The bytecode portion is conceptually similar to emulating a CPU. UIB instructions are much higher level, but they are still relatively simple instructions that are interpreted in a loop that fetches the instruction, decodes the operands, and executes it.

Nearly all of the markup-related code is in the [`Microsoft.Iris.Markup`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/) namespace, including compiled UIX. Most of the functions responsible for loading compiled UIX files is in [`Microsoft.Iris.Markup.CompiledMarkupLoader`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/CompiledMarkupLoader.cs), with some key functionality being delegated to other classes. Most notably, the bytecode interpreter is implemented in [`Microsoft.Iris.Markup.Interpreter`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/Interpreter.cs).

## Data format
Being a binary data format, UIB is capable of storing several primitive data types.

### Offsets
All offsets are stored as unsigned 32-bit integers (`UInt32`), relative to the start of the file unless otherwise specified.

### Strings
Strings are length-prefixed, with their 16-bit buffer size followed by the character bytes. Null strings are encoded with a length of `0xFFFF`, but with a true length of zero. Additional logic is performed with the highest bit, but its purpose is unknown.

### Integer arrays
Arrays of 32-bit integers are also stored prefixed with their length, where, similarly to strings, a 'negative length' is interpreted as a null array. Otherwise, each integer is stored one after the other. Both signed and unsigned integers (`UInt32` and `Int32`) can be stored with in this format, but the Iris library always reads the values as unsigned, requiring callers to unchecked cast the value to `Int32` for signed integers.

### String arrays
String arrays are effectively `Int32` arrays, where each item is an index into the string portion of the Binary Data Table.

## File structure
A custom binary format is used to store all compiler output. The first four bytes are always `0x5549421A`, which spell out `"UIB␚"` in ASCII. The purpose of the next four bytes is currently unknown.

### Table of Contents
The Table of Contents begins at offset `0x0008`, with two offsets specifying the start and end of the object section. Locations `0x0010` and `0x0014` contain the start and end of the Line Number Table, respectively.

The last item stored in the Table of Contents is a reference to the Binary Data Table. This is composed of two fields, of which only one can be set at at time. The value at offset `0x0018` is the start of a string. If the string is not null, then it is used as the resource URI to load a shared Data Table from. If it is null, then the `UInt32` at location `0x001A` is the offset to the Data Table embedded within the current file.

### Binary Data Table

#### Strings

#### Constants Table

#### Import Tables

#### Source Markup Import Tables

### Line Number Table

### Object Section

## TODO
- list the tables
    - AliasTable
    - type imports/exports
> Iris has two separate type systems-- the runtime types, which are your standard .NET types; and the markup type schemas, which of course are .NET types themselves, but are used to wrap runtime types for use by the UIX compiler and interpreter. Mapping from schema to runtime type and constructing instances from strings is easy enough, because those are both tasks the original UIX tooling has to do. Doing the reverse (finding the schema for a given runtime type, or encoding a runtime object into a string that can be parsed later) is much more difficult.