# Compiled UIX v4
Compiled UIX (often shortened to "UIB" for "UI Binary") is one of two formats used by Iris 4 for defining user interfaces. UIB is generated by passing one or more UIX XML files to the UIX compiler. The UI definition is pre-processed into custom bytecode alongside a slew of data tables. The bytecode portion is conceptually similar to emulating a CPU. UIB instructions are much higher level, but they are still relatively simple instructions that are interpreted in a loop that fetches the instruction, decodes the operands, and executes it.

Note that the format used by Iris 4 is significantly different than [Iris 3's UIB](./compiled-uix-3.md), which can be identified with the file magic `"UIX2008"`.

Nearly all of the markup-related code is in the [`Microsoft.Iris.Markup`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/) namespace, including compiled UIX. Most of the functions responsible for loading compiled UIX files is in [`Microsoft.Iris.Markup.CompiledMarkupLoader`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/CompiledMarkupLoader.cs), with some key functionality being delegated to other classes. Most notably, the bytecode interpreter is implemented in [`Microsoft.Iris.Markup.Interpreter`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/Interpreter.cs).

## Data format
Being a binary data format, UIB is capable of storing several primitive data types.

### Offsets
All offsets are stored as unsigned 32-bit integers (`UInt32`), relative to the start of the file unless otherwise specified.

### Strings
Strings are length-prefixed, with their 16-bit buffer size followed by the character bytes. Null strings are encoded with a length of `0xFFFF`. Additional logic is performed with the highest bit, but its purpose is unknown.

### Integer arrays
Arrays of 32-bit integers are also stored prefixed with their length, where, similarly to strings, a 'negative length' is interpreted as a null array. Otherwise, each integer is stored one after the other. Both signed and unsigned integers (`UInt32` and `Int32`) can be stored with in this format, but the Iris library always reads the values as unsigned, requiring callers to unchecked cast the value to `Int32` for signed integers.

### String arrays
String arrays are effectively `Int32` arrays, where each item is an index into the string portion of the Binary Data Table.

## File structure
A custom binary format is used to store all compiler output. The first four bytes are always `0x5549421A`, which spell out `"UIBâš"` in ASCII. The next four bytes contain some representation of the UIX version, although the exact format is unknown. Below is a table of known Iris versions:

| Iris version    | File version   |
| --------------- | -------------- |
| 4.8             | 1012 (`0x3F4`) |

### Table of Contents
The Table of Contents begins at offset `0x0008`, with two offsets specifying the start and end of the object section. Locations `0x0010` and `0x0014` contain the start and end of the Line Number Table, respectively.

The last item stored in the Table of Contents is a reference to the Binary Data Table. This is composed of two fields, of which only one can be set at at time. The value at offset `0x0018` is the start of a string. If the string is not null, then it is used as the resource URI to load a shared Data Table from. If it is null, then the `UInt32` at location `0x001A` is the offset to the Data Table embedded within the current file.

### Binary Data Table
The Binary Data Table consists of several subtables, with each one containing a different types of constant data. These subtables are stored in the following order:
1. Strings
1. ???

#### Strings
*[Work in progress]*

The Strings table is effectively a list of strings, though unlike the [primitive `string[]`](./compiled-uix.md#string-arrays), it is actually stored as `char[][]`. The first four bytes of the Strings table contain the length of the list as a 32-bit integer. Although this value cannot be negative, `UIX.dll` ultimately uses this as an `Int32` to allocate memory, so theoretically a maximum of `0x7FFFFFFF` or 2,147,483,647 strings.

#### Constants Table

#### Import Tables

#### Source Markup Import Tables

### Line Number Table

### Object Section

### Export Table

## Load passes
*[Work in progress]*

Compiled UIX is loaded in N main passes, listed in order of execution below. "Depersist" usually refers to reading and processing encoded information, such as type exports.
1. Declare types
    1. Depersist [Table of Contents](./compiled-uix.md#table-of-contents)
    1. Depersist [Binary Data Table](./compiled-uix.md#binary-data-table)
    1. Depersist dependencies
    1. Depersist type exports
1. Populate public model
1. Full

## TODO
- list the tables
    - AliasTable
    - type imports/exports
> Iris has two separate type systems-- the runtime types, which are your standard .NET types; and the markup type schemas, which of course are .NET types themselves, but are used to wrap runtime types for use by the UIX compiler and interpreter. Mapping from schema to runtime type and constructing instances from strings is easy enough, because those are both tasks the original UIX tooling has to do. Doing the reverse (finding the schema for a given runtime type, or encoding a runtime object into a string that can be parsed later) is much more difficult.