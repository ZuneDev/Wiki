# Compiled UIX
Compiled UIX (often shortened to "UIB" for "UI Binary") is one of two formats used by Iris 3.0+ for defining user interfaces. UIB is generated by passing one or more UIX XML files to the UIX compiler. The UI definition is pre-processed into custom bytecode alongside a slew of data tables. The bytecode portion is conceptually similar to emulating a CPU. UIB instructions are much higher level, but they are still relatively simple instructions that are interpreted in a loop that fetches the instruction, decodes the operands, and executes it.

## Data format
All offsets are stored as unsigned 32-bit integers (`UInt32`), relative to the start of the file unless otherwise specified.

Strings are length-prefixed, with their 16-bit buffer size followed by the character bytes. Null strings are encoded with a length of `0xFFFF`, but with a true length of zero. Additional logic is performed with the highest bit, but its purpose is unknown.

## File structure
A custom binary format is used to store all compiler output. The first four bytes are always `0x5549421A`, which spell out `"UIB␚"` in ASCII. The next four bytes are currently unknown.

### Table of Contents
The table of contents begins at offset `0x0008`, with two offsets specifying the start and end of the object section. Locations `0x0010` and `0x0014` contain the start and end of the line number table, respectively.

The last item stored in the table of contents is a reference to the data table. This is composed of two fields, of which only one can be set at at time. The value at offset `0x0018` is the start of a string. If the string is not null, then it is used as the resource URI to load an external data table from. If it is null, then the `UInt32` at location `0x001A` is the offset to the data table embedded within the current file.

## TODO
- list the tables
    - AliasTable
    - ConstantsTable
    - LineNumberTable
    - type imports/exports
> Iris has two separate type systems-- the runtime types, which are your standard .NET types; and the markup type schemas, which of course are .NET types themselves, but are used to wrap runtime types for use by the UIX compiler and interpreter. Mapping from schema to runtime type and constructing instances from strings is easy enough, because those are both tasks the original UIX tooling has to do. Doing the reverse (finding the schema for a given runtime type, or encoding a runtime object into a string that can be parsed later) is much more difficult.