# Compiled UIX v4
Compiled UIX (often shortened to "UIB" for "UI Binary") is one of two formats used by Iris 4 for defining user interfaces. UIB is generated by passing one or more UIX XML files to the UIX compiler. The UI definition is pre-processed into custom bytecode alongside a slew of data tables. The bytecode portion is conceptually similar to emulating a CPU. UIB instructions are much higher level, but they are still relatively simple instructions that are interpreted in a loop that fetches the instruction, decodes the operands, and executes it.

Note that the format used by Iris 4 is significantly different than [Iris 3's UIB](./compiled-uix-3.md), which can be identified with the file magic `"UIX2008"`.

Nearly all of the markup-related code is in the [`Microsoft.Iris.Markup`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/) namespace, including compiled UIX. Most of the functions responsible for loading compiled UIX files is in [`Microsoft.Iris.Markup.CompiledMarkupLoader`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/CompiledMarkupLoader.cs), with some key functionality being delegated to other classes. Most notably, the bytecode interpreter is implemented in [`Microsoft.Iris.Markup.Interpreter`](https://github.com/ZuneDev/MicrosoftIris/blob/master/UIX/Microsoft/Iris/Markup/Interpreter.cs).

## Data format
Being a binary data format, UIB is capable of storing several primitive data types.

All integers are stored in little endian, as is standard for Windows.

### Offsets
All offsets are stored as unsigned 32-bit integers (`UInt32`), relative to the start of the file unless otherwise specified.

Offset ranges are typically specified with an inclusive start offset and exclusive end offset: $[\mathrm{Start}, \mathrm{End})$.

### Strings
Strings are stored with a `UInt16` length, followed by encoded characters. Some 'length' values are used to encode special string values:

Length value (binary) | Meaning
--------------------- | --------
`1111 1111 1111 1111` | Null string
`1xxx xxxx xxxx xxxx` | UTF-8 character encoding
`0xxx xxxx xxxx xxxx` | UTF-16 character encoding

### Integer arrays
Arrays of 32-bit integers are also stored prefixed with their length, where, similarly to strings, a 'negative length' is interpreted as a null array. Otherwise, each integer is stored one after the other. Both signed and unsigned integers (`UInt32` and `Int32`) can be stored with in this format, but the Iris library always reads the values as unsigned, requiring callers to unchecked cast the value to `Int32` for signed integers.

### String arrays
String arrays are effectively `Int32` arrays, where each item is an index into the string portion of the Binary Data Table.

## File structure
A custom binary format is used to store all compiler output. This format is dividing into several sections, and in the case of [shared Data Tables](./compiled-uix.md#shared-data-tables), can be split over multiple files.

### Header
The first four bytes are always `0x5549421A`, which spell out `"UIB␚"` in ASCII. The next four bytes contain some representation of the UIB version, although the exact format is unknown. All known Iris 4 releases, including 4.0 and the 4.8 Beta, use `1012` (`0x3F4`).

### Table of Contents
The Table of Contents begins at offset `0x0008`, with two offsets specifying the start and end of the object section. Locations `0x0010` and `0x0014` contain the start and end of the Line Number Table, respectively.

The last item stored in the Table of Contents is a reference to the Binary Data Table. This is composed of two fields, of which only one can be set at at time. The value at offset `0x0018` is the start of a string. If the string is not null, then it is used as the resource URI to load a shared Data Table from. If it is null, then the `UInt32` at location `0x001A` is the offset to the Data Table embedded within the current file.

### Binary Data Table
The Binary Data Table consists of several subtables, with each one containing a different types of constant data. These subtables are stored in the following order:
1. Strings
1. ???

#### Strings
The Strings table is effectively a list of strings, though unlike the [primitive `string[]`](./compiled-uix.md#string-arrays), it is actually stored as `char[][]`.

The first four bytes of the Strings table contain the length of the list as a 32-bit integer. Although this value cannot be negative, `UIX.dll` ultimately uses this as an `Int32` to allocate memory, so theoretically a maximum of `0x7FFFFFFF` or 2,147,483,647 strings can be stored in a single UIB file.

Following the string count is a series of offsets relative to the first entry in the offset table (the byte immediately after the string count bytes). This is used sort of like a jump table, where the first chunk of the table is an array of fixed-size offsets into the second chunk. When the bytecode reader is reading from fixed memory, this allows it to jump directly to the requested string using its index without having to read the entire table or every string before it. As an example, a string table with three entries might be stored as shown below. Note that all offsets are relative to first entry in the jump table.

Start offset   | Value        | Meaning
-------------- | ------------ | -----------------------------------------
`-0x04`        | `0x03000000` | The table contains 3 strings
`0x00`         | `0x0C000000` | `strings[0]` is located at offset `0x0C`
`0x04`         | `0x1D000000` | `strings[1]` is located at offset `0x1D`
`0x08`         | `0x23000000` | `strings[2]` is located at offset `0x23`
`0x0C`         | `0x08000000` | `strings[0]` is 8 UTF-16 characters
`0x0D`         | `"Γεια σας"` | `strings[0]` character data
`0x1D`         | `0x05800000` | `strings[1]` is 5 UTF-8 characters
`0x1E`         | `"Howdy"`    | `strings[1]` character data
`0x23`         | `0x08800000` | `strings[2]` is 8 UTF-8 characters
`0x24`         | `"MOREtext"` | `strings[2]` character data

#### Constants Table

#### Import Tables

#### Source Markup Import Tables

### Line Number Table

### Object Section

### Export Table

## Load passes
*[Work in progress]*

Compiled UIX is loaded in N main passes, listed in order of execution below. "Depersist" usually refers to reading and processing encoded information, such as type exports.
1. Declare types
    1. Depersist [Table of Contents](./compiled-uix.md#table-of-contents)
    1. Depersist [Binary Data Table](./compiled-uix.md#binary-data-table)
    1. Depersist dependencies
    1. Depersist type exports
1. Populate public model
1. Full

## TODO
- list the tables
    - AliasTable
    - type imports/exports
> Iris has two separate type systems-- the runtime types, which are your standard .NET types; and the markup type schemas, which of course are .NET types themselves, but are used to wrap runtime types for use by the UIX compiler and interpreter. Mapping from schema to runtime type and constructing instances from strings is easy enough, because those are both tasks the original UIX tooling has to do. Doing the reverse (finding the schema for a given runtime type, or encoding a runtime object into a string that can be parsed later) is much more difficult.