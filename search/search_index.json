{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Howdy, Argonauts! This site contains documentation about all things related to Zune. Warning These docs are a work in progress. Topics {{ pagetree }} Credits The contents of this site were researched and written by Joshua Askharoun and Lars .","title":"Welcome"},{"location":"#welcome","text":"Howdy, Argonauts! This site contains documentation about all things related to Zune. Warning These docs are a work in progress.","title":"Welcome"},{"location":"#topics","text":"{{ pagetree }}","title":"Topics"},{"location":"#credits","text":"The contents of this site were researched and written by Joshua Askharoun and Lars .","title":"Credits"},{"location":"Atlas/","text":"Atlas Welcome, Argonauts! For a guide on how to install the OpenZDK click here . Topics OpenZDK OpenGL ES Official Documentation Windows CE 6.0 File Types XNA Framework","title":"Atlas"},{"location":"Atlas/#atlas","text":"Welcome, Argonauts! For a guide on how to install the OpenZDK click here .","title":"Atlas"},{"location":"Atlas/#topics","text":"OpenZDK OpenGL ES Official Documentation Windows CE 6.0 File Types XNA Framework","title":"Topics"},{"location":"Atlas/File%20Types/","text":"File Types The Zune uses many different file types from binary files for roms or files to package applications. Some of them are explained here. Types Firmware Files ZCP Files Gem Files","title":"File Types"},{"location":"Atlas/File%20Types/#file-types","text":"The Zune uses many different file types from binary files for roms or files to package applications. Some of them are explained here.","title":"File Types"},{"location":"Atlas/File%20Types/#types","text":"Firmware Files ZCP Files Gem Files","title":"Types"},{"location":"Atlas/Official%20Documentation/","text":"Official Documentation Here are some official docs about the Zune HD and its hardware. Documentation [[ce6_tegra_250_pack_5265393.pdf]] [[XNA_Game_Studio_3.1.pdf]] [[tegra_250_hw_setup.pdf]] [[tegra_gles2_development.pdf]] [[tegra_perfhud_quickstart_1_1.pdf]] [[win_es2emu_pack_v100.pdf]] [[tegra_gles2_performance.pdf]] CE 6.0 Documentation CE 6.0 Technical Articles CE 6.0 Docs CE 6.0 Kernel Docs CE 6.0 Kernel Reference CE 6.0 Core OS Reference CE 6.0 File Systems and Storage Management","title":"Official Documentation"},{"location":"Atlas/Official%20Documentation/#official-documentation","text":"Here are some official docs about the Zune HD and its hardware.","title":"Official Documentation"},{"location":"Atlas/Official%20Documentation/#documentation","text":"[[ce6_tegra_250_pack_5265393.pdf]] [[XNA_Game_Studio_3.1.pdf]] [[tegra_250_hw_setup.pdf]] [[tegra_gles2_development.pdf]] [[tegra_perfhud_quickstart_1_1.pdf]] [[win_es2emu_pack_v100.pdf]] [[tegra_gles2_performance.pdf]]","title":"Documentation"},{"location":"Atlas/Official%20Documentation/#ce-60-documentation","text":"CE 6.0 Technical Articles CE 6.0 Docs CE 6.0 Kernel Docs CE 6.0 Kernel Reference CE 6.0 Core OS Reference CE 6.0 File Systems and Storage Management","title":"CE 6.0 Documentation"},{"location":"Atlas/Paths/","text":"Paths Paths containing useful data / executables. XNA Device Center: C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\XNA\\Device Center OpenZDK libs/includes: C:\\Program Files (x86)\\Windows CE Tools\\wce600\\OpenZDK Remote Tools: C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Microsoft Visual Studio 2008\\Visual Studio Remote Tools XNA Assemblies (Desktop): C:\\Windows\\assembly\\GAC_MSIL\\Microsoft.Xna.GameStudio.DeviceManagement\\3.1.0.0__6d5c3888ef60e27d","title":"Paths"},{"location":"Atlas/Paths/#paths","text":"Paths containing useful data / executables. XNA Device Center: C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\XNA\\Device Center OpenZDK libs/includes: C:\\Program Files (x86)\\Windows CE Tools\\wce600\\OpenZDK Remote Tools: C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Microsoft Visual Studio 2008\\Visual Studio Remote Tools XNA Assemblies (Desktop): C:\\Windows\\assembly\\GAC_MSIL\\Microsoft.Xna.GameStudio.DeviceManagement\\3.1.0.0__6d5c3888ef60e27d","title":"Paths"},{"location":"Zune%20devices/Firmware%20Files/","text":"Firmware Files The following Information was taken from xda-developers forum: The Zune uses the B000FF file format for its firmware. It is used by Windows CE devices to write to flash memory. It saves space by skipping empty areas. There is a tutorial on how to use the tools at the bottom . File Format Header struct BIN_HEADER { char [ 7 ] Signature ; // B000FF\\n signature DWORD ImageStart ; // Image Start DWORD ImageLength ; // Image Length }; Binary Block struct BIN_BLOCK { DWORD Address ; // Address where the block should be flashed DWORD Size ; // Size of the block that is being flashed DWORD Checksum ; // Checksum (CRC32) of the block data }; [[TODO]]: Rewrite the text below: How it works The file starts with the header structure, followed by N number of block structures each one followed by the respective data of the block. A block with Address / Size / Checksum set to 0 is a termination block and marks the end of the file. Note that some blocks can be missing and depending on the bootloader the region could be left untouched or erased (erased bytes could have any value, it depends on the type of memory (NAND erased bytes have FF value) and on the bootloader). How to check the integrity of a B000FF file Read the header, read the first block and check that its address equals ImageStart , check that the termination block is present and check that the last block before the termination block address equals the sum of ImageStart + ImageLength . How to convert a B000FF file to an absolute binary format file (NB0) Allocate an empty file with the size of ImageLength and write each of the blocks' data inside at the absolute file position of Block Address - ImageStart . The missing blocks are usually empty areas (or at least that's what are in the files generated by Microsoft tools) that could be ignored by the bootloader or erased (with the bytes values depending on the memory type and on the bootloader code) but in case you encounter them make sure you investigate what those missing belong to, it could be a fancy way for the manufacturer to leave some areas reserved for the phone or bootloader and should be left untouched when re-creating the file. Available tools for working with BIN files CVRTBIN/VIEWBIN to convert the file to a \"ROM\" file (ABX/NB0/ROM memory image, call it how you want) OSNBTOOL (suggested, because it lets you figure out what is in the file) that can do the following operating: split (-sp): finds the OS.NB inside the BIN and saves the OS.NB and the unrecognized data that comes before and after it generate BIN (-2bin): converts a file to the BIN format and has two important switches, one to set the start address of the data and one to tell it to not write the header (so that you can example append other BIN data in front of it) fix BIN header (-fixbinheader) scans the BIN file and adjusts the imagestart and imagelength according to the content Extracting content Get the start and the length of the Image $ viewbin.exe nk.bin ViewBin... NK.bin Image Start = 0x00014000, length = 0x00B7A4E4 Start address = 0x00023F10 Note down the Image Start and the length Convert the .bin file to a absolute .nb0 file $ cvrtbin -r -a IMAGE_START -w 32 -l LENGTH nk.bin Replace IMAGE_START and LENGTH with the values from the last step. Finnaly dump the contents of the rom $ dumprom.exe -d dump -v -5 nk.nb0 Warning The folder specifies with -d must exist before executing the command. These steps can be repeated with the other files as well. Dumprom.exe source code https://nah6.com/~itsme/cvs-xdadevtools/dumprom/ \ud83d\uddfa\ufe0f File Types","title":"Firmware Files"},{"location":"Zune%20devices/Firmware%20Files/#firmware-files","text":"The following Information was taken from xda-developers forum: The Zune uses the B000FF file format for its firmware. It is used by Windows CE devices to write to flash memory. It saves space by skipping empty areas. There is a tutorial on how to use the tools at the bottom .","title":"Firmware Files"},{"location":"Zune%20devices/Firmware%20Files/#file-format","text":"","title":"File Format"},{"location":"Zune%20devices/Firmware%20Files/#header","text":"struct BIN_HEADER { char [ 7 ] Signature ; // B000FF\\n signature DWORD ImageStart ; // Image Start DWORD ImageLength ; // Image Length };","title":"Header"},{"location":"Zune%20devices/Firmware%20Files/#binary-block","text":"struct BIN_BLOCK { DWORD Address ; // Address where the block should be flashed DWORD Size ; // Size of the block that is being flashed DWORD Checksum ; // Checksum (CRC32) of the block data }; [[TODO]]: Rewrite the text below:","title":"Binary Block"},{"location":"Zune%20devices/Firmware%20Files/#how-it-works","text":"The file starts with the header structure, followed by N number of block structures each one followed by the respective data of the block. A block with Address / Size / Checksum set to 0 is a termination block and marks the end of the file. Note that some blocks can be missing and depending on the bootloader the region could be left untouched or erased (erased bytes could have any value, it depends on the type of memory (NAND erased bytes have FF value) and on the bootloader).","title":"How it works"},{"location":"Zune%20devices/Firmware%20Files/#how-to-check-the-integrity-of-a-b000ff-file","text":"Read the header, read the first block and check that its address equals ImageStart , check that the termination block is present and check that the last block before the termination block address equals the sum of ImageStart + ImageLength .","title":"How to check the integrity of a B000FF file"},{"location":"Zune%20devices/Firmware%20Files/#how-to-convert-a-b000ff-file-to-an-absolute-binary-format-file-nb0","text":"Allocate an empty file with the size of ImageLength and write each of the blocks' data inside at the absolute file position of Block Address - ImageStart . The missing blocks are usually empty areas (or at least that's what are in the files generated by Microsoft tools) that could be ignored by the bootloader or erased (with the bytes values depending on the memory type and on the bootloader code) but in case you encounter them make sure you investigate what those missing belong to, it could be a fancy way for the manufacturer to leave some areas reserved for the phone or bootloader and should be left untouched when re-creating the file.","title":"How to convert a B000FF file to an absolute binary format file (NB0)"},{"location":"Zune%20devices/Firmware%20Files/#available-tools-for-working-with-bin-files","text":"CVRTBIN/VIEWBIN to convert the file to a \"ROM\" file (ABX/NB0/ROM memory image, call it how you want) OSNBTOOL (suggested, because it lets you figure out what is in the file) that can do the following operating: split (-sp): finds the OS.NB inside the BIN and saves the OS.NB and the unrecognized data that comes before and after it generate BIN (-2bin): converts a file to the BIN format and has two important switches, one to set the start address of the data and one to tell it to not write the header (so that you can example append other BIN data in front of it) fix BIN header (-fixbinheader) scans the BIN file and adjusts the imagestart and imagelength according to the content","title":"Available tools for working with BIN files"},{"location":"Zune%20devices/Firmware%20Files/#extracting-content","text":"Get the start and the length of the Image $ viewbin.exe nk.bin ViewBin... NK.bin Image Start = 0x00014000, length = 0x00B7A4E4 Start address = 0x00023F10 Note down the Image Start and the length Convert the .bin file to a absolute .nb0 file $ cvrtbin -r -a IMAGE_START -w 32 -l LENGTH nk.bin Replace IMAGE_START and LENGTH with the values from the last step. Finnaly dump the contents of the rom $ dumprom.exe -d dump -v -5 nk.nb0 Warning The folder specifies with -d must exist before executing the command. These steps can be repeated with the other files as well.","title":"Extracting content"},{"location":"Zune%20devices/Firmware%20Files/#dumpromexe-source-code","text":"https://nah6.com/~itsme/cvs-xdadevtools/dumprom/ \ud83d\uddfa\ufe0f File Types","title":"Dumprom.exe source code"},{"location":"Zune%20devices/Gem%20Files/","text":"Gem Files Gem Files are essentially .XZP files (from XBOX) and pack multiple GUI related files into one archive. They contain the resources like images, layouts, controls, localization data, and so on. They are created using the Xbox UI Tool which is part of the XBOX SDK. Gem/XZP Files can be unpacked, and contain .XUI , .XUR and .XUS files. A Tool called XUIWorkshop was used to edit later versions of the file used by the XBOX. The expected version (found in the header of the file) is 8 but the Zune's gem files are at Version 5 . The official tool ( XUITool ) to edit the UI was shipped with the XBOX SDK. Tools Tools/XzpTool 2.exe : Can be used to extract the files. \ud83d\uddfa\ufe0f File Types","title":"Gem Files"},{"location":"Zune%20devices/Gem%20Files/#gem-files","text":"Gem Files are essentially .XZP files (from XBOX) and pack multiple GUI related files into one archive. They contain the resources like images, layouts, controls, localization data, and so on. They are created using the Xbox UI Tool which is part of the XBOX SDK. Gem/XZP Files can be unpacked, and contain .XUI , .XUR and .XUS files. A Tool called XUIWorkshop was used to edit later versions of the file used by the XBOX. The expected version (found in the header of the file) is 8 but the Zune's gem files are at Version 5 . The official tool ( XUITool ) to edit the UI was shipped with the XBOX SDK.","title":"Gem Files"},{"location":"Zune%20devices/Gem%20Files/#tools","text":"Tools/XzpTool 2.exe : Can be used to extract the files. \ud83d\uddfa\ufe0f File Types","title":"Tools"},{"location":"Zune%20devices/Apps/Activating%20Visual%20Studio%202008%20Profressional/","text":"Activating VS 2008 Professional Download WinSpy - Catch22 Run as Admin Goto Control Panel -> Uninstall a Program Search for Microsoft Visual Studio 2008 Professional Edition Right Click and then click Uninstall/Change Click next after loading finishes Use WinSpy to make the activation boxes visible Drag the finder tool to one of the hidden controls of the Maintenance Window In WinSpy go to the Styles tab Click the three dots next to Window Styles Remove WS_DISABLED Add WS_VISIBLE Click Apply Repeat for the remaining controls Enter a licence key (can be found online) Click Upgrade After step 4 the window should look like this: References Upgrading Visual Studio 2008 from trial to full on Windows 7 Beta (Build 7000) - Stack Overflow \ud83d\uddfa\ufe0f OpenZDK","title":"Activating VS 2008 Professional"},{"location":"Zune%20devices/Apps/Activating%20Visual%20Studio%202008%20Profressional/#activating-vs-2008-professional","text":"Download WinSpy - Catch22 Run as Admin Goto Control Panel -> Uninstall a Program Search for Microsoft Visual Studio 2008 Professional Edition Right Click and then click Uninstall/Change Click next after loading finishes Use WinSpy to make the activation boxes visible Drag the finder tool to one of the hidden controls of the Maintenance Window In WinSpy go to the Styles tab Click the three dots next to Window Styles Remove WS_DISABLED Add WS_VISIBLE Click Apply Repeat for the remaining controls Enter a licence key (can be found online) Click Upgrade After step 4 the window should look like this:","title":"Activating VS 2008 Professional"},{"location":"Zune%20devices/Apps/Activating%20Visual%20Studio%202008%20Profressional/#references","text":"Upgrading Visual Studio 2008 from trial to full on Windows 7 Beta (Build 7000) - Stack Overflow \ud83d\uddfa\ufe0f OpenZDK","title":"References"},{"location":"Zune%20devices/Apps/Keep%20WIFI%20Enabled/","text":"Keep WIFI Enabled NOTE: This is just some research Interesting entry on Zune Boards WLAN Timeout Hack - Zune Boards Keep WIFI enabled on WM5 Devices HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Power\\State\\Suspend\\{98C5250D-C29A-4985-AE5F-AFE5367E5006} -change (Default) DWORD Dec to 1 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Power\\State\\Resuming\\{98C5250D-C29A-4985-AE5F-AFE5367E5006} -change (Default) DWORD Dec to 1 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Power\\State\\Unattended\\{98C5250D-C29A-4985-AE5F-AFE5367E5006} -change (Default) DWORD Dec to 1 \ud83d\uddfa\ufe0f Windows CE 6.0","title":"Keep WIFI Enabled"},{"location":"Zune%20devices/Apps/Keep%20WIFI%20Enabled/#keep-wifi-enabled","text":"NOTE: This is just some research","title":"Keep WIFI Enabled"},{"location":"Zune%20devices/Apps/Keep%20WIFI%20Enabled/#interesting-entry-on-zune-boards","text":"WLAN Timeout Hack - Zune Boards","title":"Interesting entry on Zune Boards"},{"location":"Zune%20devices/Apps/Keep%20WIFI%20Enabled/#keep-wifi-enabled-on-wm5-devices","text":"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Power\\State\\Suspend\\{98C5250D-C29A-4985-AE5F-AFE5367E5006} -change (Default) DWORD Dec to 1 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Power\\State\\Resuming\\{98C5250D-C29A-4985-AE5F-AFE5367E5006} -change (Default) DWORD Dec to 1 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Power\\State\\Unattended\\{98C5250D-C29A-4985-AE5F-AFE5367E5006} -change (Default) DWORD Dec to 1 \ud83d\uddfa\ufe0f Windows CE 6.0","title":"Keep WIFI enabled on WM5 Devices"},{"location":"Zune%20devices/Apps/ZCP%20Files/","text":"ZCP Files NOTE: This note is still very rough, it just contains some copied info from the xda-froum. These files are XNA Storage Containers. They are essentially a mini filesystem in a single file, similar to a VHD for example. They are mounted by the Zune at runtime when launching an XNA Application . Each application is packaged into its own ZCP File. The filesystem used is called Zune Content File System (zcstfs.dll) and is actually registered by the StorageManger in the Registry at HKEY_LOCAL_MACHINE\\System\\StorageManager\\ZCSTFS . There are 3 different types of Storage Containers used by XNA: - Game Containers: Mounted automatically at /gametitle/ and stores all the deployed app content. - Runtime Containers: Mounted automatically at /gamert/ and stores all the XNA Runtime libraries. - Storage Containers: Has to be manually loaded and will be mounted at /xnaa/ . Usually used for save files. Deployment When deploying an application to the Zune, it will receive all the files from the computer and then package them into a new zcp container. It is mounted during deploy and launch of the title. DeployKit uses the same XNA apis as Visual Studio to deploy apps. \ud83d\uddfa\ufe0f File Types , \ud83d\uddfa\ufe0f XNA Framework","title":"ZCP Files"},{"location":"Zune%20devices/Apps/ZCP%20Files/#zcp-files","text":"NOTE: This note is still very rough, it just contains some copied info from the xda-froum. These files are XNA Storage Containers. They are essentially a mini filesystem in a single file, similar to a VHD for example. They are mounted by the Zune at runtime when launching an XNA Application . Each application is packaged into its own ZCP File. The filesystem used is called Zune Content File System (zcstfs.dll) and is actually registered by the StorageManger in the Registry at HKEY_LOCAL_MACHINE\\System\\StorageManager\\ZCSTFS . There are 3 different types of Storage Containers used by XNA: - Game Containers: Mounted automatically at /gametitle/ and stores all the deployed app content. - Runtime Containers: Mounted automatically at /gamert/ and stores all the XNA Runtime libraries. - Storage Containers: Has to be manually loaded and will be mounted at /xnaa/ . Usually used for save files.","title":"ZCP Files"},{"location":"Zune%20devices/Apps/ZCP%20Files/#deployment","text":"When deploying an application to the Zune, it will receive all the files from the computer and then package them into a new zcp container. It is mounted during deploy and launch of the title. DeployKit uses the same XNA apis as Visual Studio to deploy apps. \ud83d\uddfa\ufe0f File Types , \ud83d\uddfa\ufe0f XNA Framework","title":"Deployment"},{"location":"Zune%20devices/Apps/OpenZDK/","text":"OpenZDK The OpenZDK is a SDK for writing applications for the Zune and was developed by people going by the usernames itsnotabigtruck , Netrix and Nurta . In contrary to the XNA Framework, the OpenZDK allows far more control over the Zune's hardware, like access to OpenGL ES and other useful libraries. The OpenZDK works by using a bug in the Shell which allows it to execute arbitrary code outside of the very limited .NET Compact Framework. This code still runs in user mode, and not with elevated privileges. The original authors have created header and library files from Zune specific DLLs like zdksystem.dll by reverse engineering their function signatures, in order to get access to the Zune's API. Most of the documentation can be access on zunedevwiki.org (use webarchive). I will try to add as much information as possible over time, as the webarchive is painfully slow. Topics Setup Reference Activating Visual Studio 2008 Profressional Apps Liberate References Reddit - Finally got XNA 3.1 studio running Zune Dev Wiki (through web.archive.org) Reddit - Play Gameboy games on your Zune HD","title":"OpenZDK"},{"location":"Zune%20devices/Apps/OpenZDK/#openzdk","text":"The OpenZDK is a SDK for writing applications for the Zune and was developed by people going by the usernames itsnotabigtruck , Netrix and Nurta . In contrary to the XNA Framework, the OpenZDK allows far more control over the Zune's hardware, like access to OpenGL ES and other useful libraries. The OpenZDK works by using a bug in the Shell which allows it to execute arbitrary code outside of the very limited .NET Compact Framework. This code still runs in user mode, and not with elevated privileges. The original authors have created header and library files from Zune specific DLLs like zdksystem.dll by reverse engineering their function signatures, in order to get access to the Zune's API. Most of the documentation can be access on zunedevwiki.org (use webarchive). I will try to add as much information as possible over time, as the webarchive is painfully slow.","title":"OpenZDK"},{"location":"Zune%20devices/Apps/OpenZDK/#topics","text":"Setup Reference Activating Visual Studio 2008 Profressional","title":"Topics"},{"location":"Zune%20devices/Apps/OpenZDK/#apps","text":"Liberate","title":"Apps"},{"location":"Zune%20devices/Apps/OpenZDK/#references","text":"Reddit - Finally got XNA 3.1 studio running Zune Dev Wiki (through web.archive.org) Reddit - Play Gameboy games on your Zune HD","title":"References"},{"location":"Zune%20devices/Apps/OpenZDK/Liberate/","text":"Liberate Liberate is a application developed by Netrix which makes it possible to use the explorer.exe on Zune HD . It also provides functionality to run OpenGL, DirectX and Windows Apps on Liberate. Wi-Fi problem In order to save battery, the Zune automatically disables its Wi-Fi connection after a few minutes. This causes problems when trying to run executables that utilzie Wi-Fi for extended periods of time, such as when using the Windows CE Remote debugging tools through Liberate. Liberate has a somewhat working fix in RelayInput.exe , which simply pings google.com and yahoo.com every couple of minutes. However, this fix is only triggered when Liberate detects the Zune is online via ZDKCloud_IsConnected() , which nowadays always returns FALSE since it uses the now-offline Zune webservices as a litmus test for internet connectivity. Current research on a permanent fix are here . \ud83d\uddfa\ufe0f OpenZDK","title":"Liberate"},{"location":"Zune%20devices/Apps/OpenZDK/Liberate/#liberate","text":"Liberate is a application developed by Netrix which makes it possible to use the explorer.exe on Zune HD . It also provides functionality to run OpenGL, DirectX and Windows Apps on Liberate.","title":"Liberate"},{"location":"Zune%20devices/Apps/OpenZDK/Liberate/#wi-fi-problem","text":"In order to save battery, the Zune automatically disables its Wi-Fi connection after a few minutes. This causes problems when trying to run executables that utilzie Wi-Fi for extended periods of time, such as when using the Windows CE Remote debugging tools through Liberate. Liberate has a somewhat working fix in RelayInput.exe , which simply pings google.com and yahoo.com every couple of minutes. However, this fix is only triggered when Liberate detects the Zune is online via ZDKCloud_IsConnected() , which nowadays always returns FALSE since it uses the now-offline Zune webservices as a litmus test for internet connectivity. Current research on a permanent fix are here . \ud83d\uddfa\ufe0f OpenZDK","title":"Wi-Fi problem"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/","text":"Open ZDK Reference Here is a list of all the OpenZDK libraries (this list it not done yet) and their function signatures. Note that not all of the function signatures have been reverse engineered by the original team. Also make sure to either define ZUNE_HD or ZUNE_SD (for all other models) before compiling your project. Note: Function signatures that are commented out have not yet been reverse engineered. Note: zdkgl.h (use the Tegra headers instead), zdkcloud.h (Zune Cloud does not exist anymore), zcontent.h have been omitted, as they don't provide any useable functionality nowadays. zdk.h This file just includes all other ZDK header files. zdkaudio.h DLL: zdksystem.dll Coverage: 16 / 16 Description: Play audio on the Zune. zdkcontent.h DLL: zdksystem.dll Coverage: 4 / 7 Description: Open XNA Storage Containers / ZCP Files zdkdisplay.h DLL: zdksystem.dll Coverage: 22 / 23 Description: Functionality for 2D rendering (with DirectX or DirectDraw??) zdkfont.h DLL: ??? Coverage: 7 / 8 Description: Text Rendering zdkimage.h DLL: ??? Coverage: ??? Description: Image Loading/Processing zdkinput.h DLL: ??? Coverage: ??? Description: Get touch and accelerometer data \ud83d\uddfa\ufe0f OpenZDK","title":"Open ZDK Reference"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#open-zdk-reference","text":"Here is a list of all the OpenZDK libraries (this list it not done yet) and their function signatures. Note that not all of the function signatures have been reverse engineered by the original team. Also make sure to either define ZUNE_HD or ZUNE_SD (for all other models) before compiling your project. Note: Function signatures that are commented out have not yet been reverse engineered. Note: zdkgl.h (use the Tegra headers instead), zdkcloud.h (Zune Cloud does not exist anymore), zcontent.h have been omitted, as they don't provide any useable functionality nowadays.","title":"Open ZDK Reference"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#zdkh","text":"This file just includes all other ZDK header files.","title":"zdk.h"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#zdkaudioh","text":"DLL: zdksystem.dll Coverage: 16 / 16 Description: Play audio on the Zune.","title":"zdkaudio.h"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#zdkcontenth","text":"DLL: zdksystem.dll Coverage: 4 / 7 Description: Open XNA Storage Containers / ZCP Files","title":"zdkcontent.h"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#zdkdisplayh","text":"DLL: zdksystem.dll Coverage: 22 / 23 Description: Functionality for 2D rendering (with DirectX or DirectDraw??)","title":"zdkdisplay.h"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#zdkfonth","text":"DLL: ??? Coverage: 7 / 8 Description: Text Rendering","title":"zdkfont.h"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#zdkimageh","text":"DLL: ??? Coverage: ??? Description: Image Loading/Processing","title":"zdkimage.h"},{"location":"Zune%20devices/Apps/OpenZDK/Reference/#zdkinputh","text":"DLL: ??? Coverage: ??? Description: Get touch and accelerometer data \ud83d\uddfa\ufe0f OpenZDK","title":"zdkinput.h"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/","text":"Setup This step by step guide will show you how to install all the tools needed to develop OpenZDK Apps on Windows 10. Make sure to follow all the steps in the right order. Note: Installing the actual OpenZDK is only necessary if you want to develop applications or use tooling associated with it. You can download all the installers (except Visual Studio 2008) from here . Visual Studio 2008 Pro (90 day trial) can be downloaded from Microsoft here . Installing prerequisites Install Visual Studio 2008 Professional Make sure to select Smart Device Programmability when installing. This is only available in the Pro versions of Visual studio. (Optional) Install Visual Studio 2008 SP1 Install XNA Game Studio 3.1 ( XNAGS31_setup.exe ) On Windows 10 this needs some extra steps as the installer is broken. Thanks to this Reddit Post for elaborating how to extract the installer: Open a Command Prompt and navigate to the directory of the installer Run the installer with the /x option like this: XNA3.1.exe /x Run every MSI installer you see that got extracted Run everything in C:\\Program Files (x86)\\Microsoft XNA\\XNA Game Studio\\v3.1\\Setup Install Zune HD extensions for XNA Game Studio.msi Setup your Zune in XNA Game Studio Plug in your Zune and make sure that the Zune Software is completely closed. Open XNA Game Studio Device Center which is located at C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\XNA\\Device Center Click Add Device , then Zune Select your Zune and continue through the remaining steps Install OpenZDK Close all instances of Visual Studio Install the OpenZDK ( openzdk-hd-4.5-20100414.msi ), can be found in the Quick Start Kit Select Custom installation type Set Documentation to Entire feature will be unavailable - The docs are only available if you have Visual Studio 2005 installed, and don't provide any OpenZDK specific information anyways Continue through the remaining steps Install the Platform Support Pack (for OpenGL) Install Standard SDK for Windows CE 5.0 ( STANDARD_SDK.msi ): The Nvidia installer needs this to finish installing Install NVIDIA Tegra 250 Platform Support Pack ( ce6_tegra_250_5265393.msi ): This contains all the library needed to use the NVIDIA hardware Setting up Visual Studio for development Updating the include path In Visual Studio select Options > Tools > Projects and Solutions > VC++ Directories Select OpenZDK (ARMV4I) from the Platform dropdown Select Include files from the Show directories for dropdown Click the New line button Enter $(NV_WINCE_T2_PLAT)\\include and press enter Updating the library path Select Library files from the Show directories for dropdown Click the New line button Enter $(NV_WINCE_T2_PLAT)\\lib\\release and press enter That's it! Have fun developing :) Check out the \ud83d\uddfa\ufe0f Official Documentation or OpenZDK Reference for more information about the available APIs. To activate VS 2008 look here . References Reddit - Finally got XNA 3.1 studio running ZuneDevWiki - Installing prerequisites ZuneDevWiki - Preparing the Zune development environment \ud83d\uddfa\ufe0f OpenZDK","title":"Setup"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/#setup","text":"This step by step guide will show you how to install all the tools needed to develop OpenZDK Apps on Windows 10. Make sure to follow all the steps in the right order. Note: Installing the actual OpenZDK is only necessary if you want to develop applications or use tooling associated with it. You can download all the installers (except Visual Studio 2008) from here . Visual Studio 2008 Pro (90 day trial) can be downloaded from Microsoft here .","title":"Setup"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/#installing-prerequisites","text":"Install Visual Studio 2008 Professional Make sure to select Smart Device Programmability when installing. This is only available in the Pro versions of Visual studio. (Optional) Install Visual Studio 2008 SP1 Install XNA Game Studio 3.1 ( XNAGS31_setup.exe ) On Windows 10 this needs some extra steps as the installer is broken. Thanks to this Reddit Post for elaborating how to extract the installer: Open a Command Prompt and navigate to the directory of the installer Run the installer with the /x option like this: XNA3.1.exe /x Run every MSI installer you see that got extracted Run everything in C:\\Program Files (x86)\\Microsoft XNA\\XNA Game Studio\\v3.1\\Setup Install Zune HD extensions for XNA Game Studio.msi","title":"Installing prerequisites"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/#setup-your-zune-in-xna-game-studio","text":"Plug in your Zune and make sure that the Zune Software is completely closed. Open XNA Game Studio Device Center which is located at C:\\Program Files (x86)\\Common Files\\Microsoft Shared\\XNA\\Device Center Click Add Device , then Zune Select your Zune and continue through the remaining steps","title":"Setup your Zune in XNA Game Studio"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/#install-openzdk","text":"Close all instances of Visual Studio Install the OpenZDK ( openzdk-hd-4.5-20100414.msi ), can be found in the Quick Start Kit Select Custom installation type Set Documentation to Entire feature will be unavailable - The docs are only available if you have Visual Studio 2005 installed, and don't provide any OpenZDK specific information anyways Continue through the remaining steps","title":"Install OpenZDK"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/#install-the-platform-support-pack-for-opengl","text":"Install Standard SDK for Windows CE 5.0 ( STANDARD_SDK.msi ): The Nvidia installer needs this to finish installing Install NVIDIA Tegra 250 Platform Support Pack ( ce6_tegra_250_5265393.msi ): This contains all the library needed to use the NVIDIA hardware","title":"Install the Platform Support Pack (for OpenGL)"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/#setting-up-visual-studio-for-development","text":"Updating the include path In Visual Studio select Options > Tools > Projects and Solutions > VC++ Directories Select OpenZDK (ARMV4I) from the Platform dropdown Select Include files from the Show directories for dropdown Click the New line button Enter $(NV_WINCE_T2_PLAT)\\include and press enter Updating the library path Select Library files from the Show directories for dropdown Click the New line button Enter $(NV_WINCE_T2_PLAT)\\lib\\release and press enter That's it! Have fun developing :) Check out the \ud83d\uddfa\ufe0f Official Documentation or OpenZDK Reference for more information about the available APIs. To activate VS 2008 look here .","title":"Setting up Visual Studio for development"},{"location":"Zune%20devices/Apps/OpenZDK/Setup/#references","text":"Reddit - Finally got XNA 3.1 studio running ZuneDevWiki - Installing prerequisites ZuneDevWiki - Preparing the Zune development environment \ud83d\uddfa\ufe0f OpenZDK","title":"References"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/ZDKSystem_ShowSplashScreen/","text":"ZDKSystem_ShowSplashScreen(int flag) If flag is set to 1, Zune will try to initialize the Massive AdClientLite (zmassive.dll). This was probably once used to display ads before starting a Zune Marketplace App. However the servers are long gone so nothing happens.","title":"ZDKSystem_ShowSplashScreen(int flag)"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/ZDKSystem_ShowSplashScreen/#zdksystem_showsplashscreenint-flag","text":"If flag is set to 1, Zune will try to initialize the Massive AdClientLite (zmassive.dll). This was probably once used to display ads before starting a Zune Marketplace App. However the servers are long gone so nothing happens.","title":"ZDKSystem_ShowSplashScreen(int flag)"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkaudio.h/","text":"zdkaudio.h /* Initialization */ HRESULT WINAPI ZDKAudio_Initialize (); HRESULT WINAPI ZDKAudio_Shutdown (); /* Control Voices */ HRESULT WINAPI ZDKAudio_CreateVoice ( const WAVEFORMATEX * format , DWORD formatSize , HVOICE * handle ); HRESULT WINAPI ZDKAudio_DestroyVoice ( HVOICE handle ); /* Playback Control */ HRESULT WINAPI ZDKAudio_GetPan ( HVOICE handle , float * pan ); HRESULT WINAPI ZDKAudio_GetPitch ( HVOICE handle , float * pitch ); HRESULT WINAPI ZDKAudio_GetVoiceState ( HVOICE handle , ZDK_VOICE_STATE * state ); HRESULT WINAPI ZDKAudio_GetVolume ( HVOICE handle , float * volume ); HRESULT WINAPI ZDKAudio_Pause ( HVOICE handle ); HRESULT WINAPI ZDKAudio_Play ( HVOICE handle ); HRESULT WINAPI ZDKAudio_SetMasterVolume ( float volume ); HRESULT WINAPI ZDKAudio_SetPan ( HVOICE handle , float pan ); HRESULT WINAPI ZDKAudio_SetPitch ( HVOICE handle , float pitch ); HRESULT WINAPI ZDKAudio_SetVolume ( HVOICE handle , float volume ); HRESULT WINAPI ZDKAudio_Stop ( HVOICE handle , BOOL immediate ); /* Send Audio Data*/ HRESULT WINAPI ZDKAudio_SubmitPacket ( HVOICE handle , const BYTE * data , DWORD dataSize , int loopStart , int loopLength , int loopCount ); /* Types */ typedef enum { VOICE_STATE_PLAYING = 0x1 , VOICE_STATE_STOPPING = 0x2 , VOICE_STATE_STOPPED = 0x4 , VOICE_STATE_PAUSED = 0x8 } ZDK_VOICE_STATE ; OpenZDK Reference","title":"zdkaudio.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkaudio.h/#zdkaudioh","text":"/* Initialization */ HRESULT WINAPI ZDKAudio_Initialize (); HRESULT WINAPI ZDKAudio_Shutdown (); /* Control Voices */ HRESULT WINAPI ZDKAudio_CreateVoice ( const WAVEFORMATEX * format , DWORD formatSize , HVOICE * handle ); HRESULT WINAPI ZDKAudio_DestroyVoice ( HVOICE handle ); /* Playback Control */ HRESULT WINAPI ZDKAudio_GetPan ( HVOICE handle , float * pan ); HRESULT WINAPI ZDKAudio_GetPitch ( HVOICE handle , float * pitch ); HRESULT WINAPI ZDKAudio_GetVoiceState ( HVOICE handle , ZDK_VOICE_STATE * state ); HRESULT WINAPI ZDKAudio_GetVolume ( HVOICE handle , float * volume ); HRESULT WINAPI ZDKAudio_Pause ( HVOICE handle ); HRESULT WINAPI ZDKAudio_Play ( HVOICE handle ); HRESULT WINAPI ZDKAudio_SetMasterVolume ( float volume ); HRESULT WINAPI ZDKAudio_SetPan ( HVOICE handle , float pan ); HRESULT WINAPI ZDKAudio_SetPitch ( HVOICE handle , float pitch ); HRESULT WINAPI ZDKAudio_SetVolume ( HVOICE handle , float volume ); HRESULT WINAPI ZDKAudio_Stop ( HVOICE handle , BOOL immediate ); /* Send Audio Data*/ HRESULT WINAPI ZDKAudio_SubmitPacket ( HVOICE handle , const BYTE * data , DWORD dataSize , int loopStart , int loopLength , int loopCount ); /* Types */ typedef enum { VOICE_STATE_PLAYING = 0x1 , VOICE_STATE_STOPPING = 0x2 , VOICE_STATE_STOPPED = 0x4 , VOICE_STATE_PAUSED = 0x8 } ZDK_VOICE_STATE ; OpenZDK Reference","title":"zdkaudio.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkcontent.h/","text":"zdkcontent.h /* Container Management */ HRESULT WINAPI ZDKContent_Create ( ZDK_CONTAINER_INFO * info , int w , int x , int y , int z ); HRESULT WINAPI ZDKContent_Mount ( LPCWSTR mountPoint , ZDK_CONTAINER_INFO * info , BOOL flag ); HRESULT WINAPI ZDKContent_Unmount ( LPCWSTR mountPoint ); HRESULT WINAPI ZDKContent_UnmountAll (); /* ZDKContent_Delete */ /* ZDKContent_Flush */ /* ZDKContent_SetMetaData */ /* ZDKContent_SetThumbnail */ /* ZDKContent_FindClose */ /* ZDKContent_FindFirst */ /* ZDKContent_FindNext */ /* Types */ typedef enum { CONTAINER_TYPE_RUNTIME = 0x1 , CONTAINER_TYPE_APPLICATION = 0x2 , CONTAINER_TYPE_STORAGE = 0x3 } ZDK_CONTAINER_TYPE ; typedef struct { GUID UserGuid ; GUID VirtualTitleId ; ZDK_CONTAINER_TYPE ContainerType ; wchar_t Name [ 40 ]; } ZDK_CONTAINER_INFO ; OpenZDK Reference","title":"zdkcontent.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkcontent.h/#zdkcontenth","text":"/* Container Management */ HRESULT WINAPI ZDKContent_Create ( ZDK_CONTAINER_INFO * info , int w , int x , int y , int z ); HRESULT WINAPI ZDKContent_Mount ( LPCWSTR mountPoint , ZDK_CONTAINER_INFO * info , BOOL flag ); HRESULT WINAPI ZDKContent_Unmount ( LPCWSTR mountPoint ); HRESULT WINAPI ZDKContent_UnmountAll (); /* ZDKContent_Delete */ /* ZDKContent_Flush */ /* ZDKContent_SetMetaData */ /* ZDKContent_SetThumbnail */ /* ZDKContent_FindClose */ /* ZDKContent_FindFirst */ /* ZDKContent_FindNext */ /* Types */ typedef enum { CONTAINER_TYPE_RUNTIME = 0x1 , CONTAINER_TYPE_APPLICATION = 0x2 , CONTAINER_TYPE_STORAGE = 0x3 } ZDK_CONTAINER_TYPE ; typedef struct { GUID UserGuid ; GUID VirtualTitleId ; ZDK_CONTAINER_TYPE ContainerType ; wchar_t Name [ 40 ]; } ZDK_CONTAINER_INFO ; OpenZDK Reference","title":"zdkcontent.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkdisplay.h/","text":"zdkdisplay.h /* 2D initialization */ HRESULT WINAPI ZDKDisplay_Initialize (); HRESULT WINAPI ZDKDisplay_Cleanup (); /* System information */ HRESULT WINAPI ZDKDisplay_GetInfo ( DWORD * screenWidth , DWORD * screenHeight ); /* Texture management */ HRESULT WINAPI ZDKDisplay_CreateTexture ( DWORD width , DWORD height , HTEXTURE * texture ); HRESULT WINAPI ZDKDisplay_FreeTexture ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_GetTextureData ( HTEXTURE texture , ZDK_RECT * rect , void * buffer , DWORD dataSize ); HRESULT WINAPI ZDKDisplay_GetTextureInfo ( HTEXTURE texture , DWORD * width , DWORD * height ); HRESULT WINAPI ZDKDisplay_SetTextureData ( HTEXTURE texture , ZDK_RECT * rect , void * buffer , DWORD dataSize ); HRESULT WINAPI ZDKDisplay_TextureLockRect ( HTEXTURE texture , ZDK_TEXTURE_LOCK_INFO * info , ZDK_RECT * rect , ZDK_TEXTURE_LOCK_FLAGS flags ); HRESULT WINAPI ZDKDisplay_TextureUnlockRect ( HTEXTURE texture ); /* Rendering */ HRESULT WINAPI ZDKDisplay_BeginScene (); HRESULT WINAPI ZDKDisplay_Clear ( DWORD color ); HRESULT WINAPI ZDKDisplay_DrawSprites ( ZDK_SPRITE * sprites , DWORD spriteCount ); HRESULT WINAPI ZDKDisplay_EndScene (); HRESULT WINAPI ZDKDisplay_Present (); HRESULT WINAPI ZDKDisplay_ResolveBackBuffer ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_SetBlendMode ( ZDK_BLEND_MODE blendMode ); HRESULT WINAPI ZDKDisplay_SetClipRect ( ZDK_RECT * rect ); HRESULT WINAPI ZDKDisplay_SetRenderTarget ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_SetTexture ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_SetTransform ( ZDK_MATRIX * matrix ); /* ZDKDisplay_SetTextureFilter */ /* Types */ typedef float ZDK_MATRIX [ 4 ][ 4 ]; typedef struct { int Left ; int Top ; int Right ; int Bottom ; } ZDK_RECT ; typedef enum { BLEND_MODE_NONE , BLEND_MODE_ALPHA_BLEND , BLEND_MODE_ADDITIVE } ZDK_BLEND_MODE ; typedef struct { float X ; float Y ; float U ; float V ; } ZDK_VERTEXDATA ; typedef struct { ZDK_VERTEXDATA Vertices [ 4 ]; DWORD Color ; } ZDK_SPRITE ; DECLARE_HANDLE ( HTEXTURE ); typedef enum { TEXTURE_LOCK_DEFAULT = 0x0 , TEXTURE_LOCK_READONLY = 0x10 , TEXTURE_LOCK_NOSYSLOCK = 0x800 , /* questionable */ TEXTURE_LOCK_NOOVERWRITE = 0x1000 , /* questionable */ TEXTURE_LOCK_DISCARD = 0x2000 , TEXTURE_LOCK_NO_DIRTY_UPDATE = 0x8000 /* questionable */ } ZDK_TEXTURE_LOCK_FLAGS ; typedef struct { int Pitch ; DWORD * Buffer ; } ZDK_TEXTURE_LOCK_INFO ; OpenZDK Reference","title":"zdkdisplay.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkdisplay.h/#zdkdisplayh","text":"/* 2D initialization */ HRESULT WINAPI ZDKDisplay_Initialize (); HRESULT WINAPI ZDKDisplay_Cleanup (); /* System information */ HRESULT WINAPI ZDKDisplay_GetInfo ( DWORD * screenWidth , DWORD * screenHeight ); /* Texture management */ HRESULT WINAPI ZDKDisplay_CreateTexture ( DWORD width , DWORD height , HTEXTURE * texture ); HRESULT WINAPI ZDKDisplay_FreeTexture ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_GetTextureData ( HTEXTURE texture , ZDK_RECT * rect , void * buffer , DWORD dataSize ); HRESULT WINAPI ZDKDisplay_GetTextureInfo ( HTEXTURE texture , DWORD * width , DWORD * height ); HRESULT WINAPI ZDKDisplay_SetTextureData ( HTEXTURE texture , ZDK_RECT * rect , void * buffer , DWORD dataSize ); HRESULT WINAPI ZDKDisplay_TextureLockRect ( HTEXTURE texture , ZDK_TEXTURE_LOCK_INFO * info , ZDK_RECT * rect , ZDK_TEXTURE_LOCK_FLAGS flags ); HRESULT WINAPI ZDKDisplay_TextureUnlockRect ( HTEXTURE texture ); /* Rendering */ HRESULT WINAPI ZDKDisplay_BeginScene (); HRESULT WINAPI ZDKDisplay_Clear ( DWORD color ); HRESULT WINAPI ZDKDisplay_DrawSprites ( ZDK_SPRITE * sprites , DWORD spriteCount ); HRESULT WINAPI ZDKDisplay_EndScene (); HRESULT WINAPI ZDKDisplay_Present (); HRESULT WINAPI ZDKDisplay_ResolveBackBuffer ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_SetBlendMode ( ZDK_BLEND_MODE blendMode ); HRESULT WINAPI ZDKDisplay_SetClipRect ( ZDK_RECT * rect ); HRESULT WINAPI ZDKDisplay_SetRenderTarget ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_SetTexture ( HTEXTURE texture ); HRESULT WINAPI ZDKDisplay_SetTransform ( ZDK_MATRIX * matrix ); /* ZDKDisplay_SetTextureFilter */ /* Types */ typedef float ZDK_MATRIX [ 4 ][ 4 ]; typedef struct { int Left ; int Top ; int Right ; int Bottom ; } ZDK_RECT ; typedef enum { BLEND_MODE_NONE , BLEND_MODE_ALPHA_BLEND , BLEND_MODE_ADDITIVE } ZDK_BLEND_MODE ; typedef struct { float X ; float Y ; float U ; float V ; } ZDK_VERTEXDATA ; typedef struct { ZDK_VERTEXDATA Vertices [ 4 ]; DWORD Color ; } ZDK_SPRITE ; DECLARE_HANDLE ( HTEXTURE ); typedef enum { TEXTURE_LOCK_DEFAULT = 0x0 , TEXTURE_LOCK_READONLY = 0x10 , TEXTURE_LOCK_NOSYSLOCK = 0x800 , /* questionable */ TEXTURE_LOCK_NOOVERWRITE = 0x1000 , /* questionable */ TEXTURE_LOCK_DISCARD = 0x2000 , TEXTURE_LOCK_NO_DIRTY_UPDATE = 0x8000 /* questionable */ } ZDK_TEXTURE_LOCK_FLAGS ; typedef struct { int Pitch ; DWORD * Buffer ; } ZDK_TEXTURE_LOCK_INFO ; OpenZDK Reference","title":"zdkdisplay.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkfont.h/","text":"zdkfont.h typedef enum { FONT_STYLE_ITALIC = 2 , FONT_STYLE_BOLD = 4 } ZDK_FONT_STYLE ; HRESULT WINAPI ZDKFont_Cleanup (); HRESULT WINAPI ZDKFont_Create ( LPCWSTR typeface , float size , ZDK_FONT_STYLE style , HGDIOBJ * font ); HRESULT WINAPI ZDKFont_Destroy ( HGDIOBJ font ); HRESULT WINAPI ZDKFont_Initialize (); /* ZDKFont_DrawCharToBuffer */ /* ZDKFont_GetCharMetrics */ /* ZDKFont_GetFontMetrics */ OpenZDK Reference","title":"zdkfont.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkfont.h/#zdkfonth","text":"typedef enum { FONT_STYLE_ITALIC = 2 , FONT_STYLE_BOLD = 4 } ZDK_FONT_STYLE ; HRESULT WINAPI ZDKFont_Cleanup (); HRESULT WINAPI ZDKFont_Create ( LPCWSTR typeface , float size , ZDK_FONT_STYLE style , HGDIOBJ * font ); HRESULT WINAPI ZDKFont_Destroy ( HGDIOBJ font ); HRESULT WINAPI ZDKFont_Initialize (); /* ZDKFont_DrawCharToBuffer */ /* ZDKFont_GetCharMetrics */ /* ZDKFont_GetFontMetrics */ OpenZDK Reference","title":"zdkfont.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkimage.h/","text":"zdkimage.h HRESULT WINAPI ZDKImage_CreateImageFromBuffer ( const void * buffer , DWORD length , HIMAGE * image ); HRESULT WINAPI ZDKImage_CreateImageFromFile ( LPCWSTR path , HIMAGE * image ); HRESULT WINAPI ZDKImage_GetImageData ( HIMAGE image , void * buffer , DWORD length ); HRESULT WINAPI ZDKImage_GetImageSize ( HIMAGE image , DWORD * width , DWORD * height ); HRESULT WINAPI ZDKImage_ReleaseImage ( HIMAGE image ); DECLARE_HANDLE ( HIMAGE ); OpenZDK Reference","title":"zdkimage.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkimage.h/#zdkimageh","text":"HRESULT WINAPI ZDKImage_CreateImageFromBuffer ( const void * buffer , DWORD length , HIMAGE * image ); HRESULT WINAPI ZDKImage_CreateImageFromFile ( LPCWSTR path , HIMAGE * image ); HRESULT WINAPI ZDKImage_GetImageData ( HIMAGE image , void * buffer , DWORD length ); HRESULT WINAPI ZDKImage_GetImageSize ( HIMAGE image , DWORD * width , DWORD * height ); HRESULT WINAPI ZDKImage_ReleaseImage ( HIMAGE image ); DECLARE_HANDLE ( HIMAGE ); OpenZDK Reference","title":"zdkimage.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkinput.h/","text":"zdkinput.h /* Initialization */ HRESULT WINAPI ZDKInput_Initialize (); HRESULT WINAPI ZDKInput_Shutdown (); /* State */ HRESULT WINAPI ZDKInput_GetState ( ZDK_INPUT_STATE * state ); /* ZDKInput_GetNextInputMessage */ /* ZDKInput_EnableInputMessages */ /* Types */ typedef struct { int X ; int Y ; int Z ; } ZDK_ACCELEROMETER_STATE ; typedef struct { unsigned int Id ; float X ; float Y ; float Pressure ; } ZDK_TOUCH_LOCATION ; typedef struct { int Count ; ZDK_TOUCH_LOCATION Locations [ 4 ]; } ZDK_TOUCH_STATE ; typedef struct { ZDK_TOUCH_STATE TouchState ; ZDK_ACCELEROMETER_STATE AccelerometerState ; } ZDK_INPUT_STATE_HD ; /* Zune SD types for dpad have been omitted but can be found in the original header file*/ OpenZDK Reference","title":"zdkinput.h"},{"location":"Zune%20devices/Apps/OpenZDK/Headers/zdkinput.h/#zdkinputh","text":"/* Initialization */ HRESULT WINAPI ZDKInput_Initialize (); HRESULT WINAPI ZDKInput_Shutdown (); /* State */ HRESULT WINAPI ZDKInput_GetState ( ZDK_INPUT_STATE * state ); /* ZDKInput_GetNextInputMessage */ /* ZDKInput_EnableInputMessages */ /* Types */ typedef struct { int X ; int Y ; int Z ; } ZDK_ACCELEROMETER_STATE ; typedef struct { unsigned int Id ; float X ; float Y ; float Pressure ; } ZDK_TOUCH_LOCATION ; typedef struct { int Count ; ZDK_TOUCH_LOCATION Locations [ 4 ]; } ZDK_TOUCH_STATE ; typedef struct { ZDK_TOUCH_STATE TouchState ; ZDK_ACCELEROMETER_STATE AccelerometerState ; } ZDK_INPUT_STATE_HD ; /* Zune SD types for dpad have been omitted but can be found in the original header file*/ OpenZDK Reference","title":"zdkinput.h"},{"location":"Zune%20devices/Apps/XNA%20Framework/","text":"XNA Framework The Zune uses the XNA 3.1 Framework. Topics XNA Apps ZCP Files","title":"XNA Framework"},{"location":"Zune%20devices/Apps/XNA%20Framework/#xna-framework","text":"The Zune uses the XNA 3.1 Framework.","title":"XNA Framework"},{"location":"Zune%20devices/Apps/XNA%20Framework/#topics","text":"XNA Apps ZCP Files","title":"Topics"},{"location":"Zune%20devices/Apps/XNA%20Framework/XNA%20Apps/","text":"XNA Apps Before the OpenZDK was released it was only possible to build apps using the XNA Framework. These apps use the .NET Compact Framework and the XNA Framework to run. The .NET Compact Framework is a tiny subset of the .NET framework and doesn't even know about the OS it is running on. Files XNA Apps run in their own ZCP container, and can only access data from their own container. This access restriction is only imposed by the XNA Framework/.NET Framework, as \ud83d\uddfa\ufe0f OpenZDK apps have access to more files. Although they still can't access any system files. By default two containers are mounted: gamert : Hosts all the XNA Runtime libraries gametitle : Hosts the content of XNA application The path where the content is accessible seems to be: \\gametitle\\584E07D1\\Content . XNA Apps can also open other Storage Containers, which are usually used for save files. These containers are accessible through the GamerServices . Using these you can \"show\" the user a device selector, where in theory they could select the drive they would like to store their save files to. On the Zune this does nothing, but is still needed in order to gain access to such a storage container. The XNA Framework was mainly developed for the XBOX. This is why that weird step is needed. Code Sample: IAsyncResult async = Microsoft . Xna . Framework . GamerServices . Guide . BeginShowStorageDeviceSelector ( null , null ); var storage = Microsoft . Xna . Framework . GamerServices . Guide . EndShowStorageDeviceSelector ( async ); Debug . WriteLine ( \"Is connected: \" + storage . IsConnected ); var container = storage . OpenContainer ( \"ZuneCraft\" ); Debug . WriteLine ( \"Container Path: \" + container . Path ); The file path can be composited using container.Path + PATH_TO_YOUR_FILE . \ud83d\uddfa\ufe0f XNA Framework","title":"XNA Apps"},{"location":"Zune%20devices/Apps/XNA%20Framework/XNA%20Apps/#xna-apps","text":"Before the OpenZDK was released it was only possible to build apps using the XNA Framework. These apps use the .NET Compact Framework and the XNA Framework to run. The .NET Compact Framework is a tiny subset of the .NET framework and doesn't even know about the OS it is running on.","title":"XNA Apps"},{"location":"Zune%20devices/Apps/XNA%20Framework/XNA%20Apps/#files","text":"XNA Apps run in their own ZCP container, and can only access data from their own container. This access restriction is only imposed by the XNA Framework/.NET Framework, as \ud83d\uddfa\ufe0f OpenZDK apps have access to more files. Although they still can't access any system files. By default two containers are mounted: gamert : Hosts all the XNA Runtime libraries gametitle : Hosts the content of XNA application The path where the content is accessible seems to be: \\gametitle\\584E07D1\\Content . XNA Apps can also open other Storage Containers, which are usually used for save files. These containers are accessible through the GamerServices . Using these you can \"show\" the user a device selector, where in theory they could select the drive they would like to store their save files to. On the Zune this does nothing, but is still needed in order to gain access to such a storage container. The XNA Framework was mainly developed for the XBOX. This is why that weird step is needed. Code Sample: IAsyncResult async = Microsoft . Xna . Framework . GamerServices . Guide . BeginShowStorageDeviceSelector ( null , null ); var storage = Microsoft . Xna . Framework . GamerServices . Guide . EndShowStorageDeviceSelector ( async ); Debug . WriteLine ( \"Is connected: \" + storage . IsConnected ); var container = storage . OpenContainer ( \"ZuneCraft\" ); Debug . WriteLine ( \"Container Path: \" + container . Path ); The file path can be composited using container.Path + PATH_TO_YOUR_FILE . \ud83d\uddfa\ufe0f XNA Framework","title":"Files"},{"location":"Zune%20devices/Zune%20HD/","text":"Zune HD The Zune HD was released on September 15, 2009 and was the last Zune to be released by Microsoft. The device is codenamed \"Pavo\". Hardware CPU: Nvidia Tegra APX 2600 ARM11 + ARM7 cores ARMv6 ISA Graphics: OpenGL ES 2.0 RAM: 128MB SDRAM User storage: 16/32/64GB flash Toshiba TH58NVG8D2ELA89 64GB Display: 3.3\" touchscreen 480\u00d7272px OLED Multitouch Connectivity Wi-Fi 802.11b/g WPA/WPA2 USB 2.0 MTPZ (Media Transport Protocol with proprietary Zune extensions and signing) Procedures Device recovery and reset Holding the side button down during boot will put the device into system recovery, which allows the Zune software to update the firmware. Holding both the side and front buttons will irreversibly wipe the device of all data. Media library dump The device's media library, including Marketplace data such as artist images and biographys, can be dumped to a file on the host machine by setting a specific registry key. Navigate to HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Devices . Create a string key named ZMDBSaveToFile . Set the key to the file path you wish to save to. Ensure that backslashes are escaped with a second backslash (e.g. C:\\Users\\you\\zune.zmdb becomes C:\\\\Users\\\\you\\\\zune.zmdb ). Plug in your device and launch the Zune software. The resulting file is stored in the ZMDB format, for which no tools currently exist. References Wikipedia Zune HD","title":"Zune HD"},{"location":"Zune%20devices/Zune%20HD/#zune-hd","text":"The Zune HD was released on September 15, 2009 and was the last Zune to be released by Microsoft. The device is codenamed \"Pavo\".","title":"Zune HD"},{"location":"Zune%20devices/Zune%20HD/#hardware","text":"CPU: Nvidia Tegra APX 2600 ARM11 + ARM7 cores ARMv6 ISA Graphics: OpenGL ES 2.0 RAM: 128MB SDRAM User storage: 16/32/64GB flash Toshiba TH58NVG8D2ELA89 64GB Display: 3.3\" touchscreen 480\u00d7272px OLED Multitouch Connectivity Wi-Fi 802.11b/g WPA/WPA2 USB 2.0 MTPZ (Media Transport Protocol with proprietary Zune extensions and signing)","title":"Hardware"},{"location":"Zune%20devices/Zune%20HD/#procedures","text":"","title":"Procedures"},{"location":"Zune%20devices/Zune%20HD/#device-recovery-and-reset","text":"Holding the side button down during boot will put the device into system recovery, which allows the Zune software to update the firmware. Holding both the side and front buttons will irreversibly wipe the device of all data.","title":"Device recovery and reset"},{"location":"Zune%20devices/Zune%20HD/#media-library-dump","text":"The device's media library, including Marketplace data such as artist images and biographys, can be dumped to a file on the host machine by setting a specific registry key. Navigate to HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Devices . Create a string key named ZMDBSaveToFile . Set the key to the file path you wish to save to. Ensure that backslashes are escaped with a second backslash (e.g. C:\\Users\\you\\zune.zmdb becomes C:\\\\Users\\\\you\\\\zune.zmdb ). Plug in your device and launch the Zune software. The resulting file is stored in the ZMDB format, for which no tools currently exist.","title":"Media library dump"},{"location":"Zune%20devices/Zune%20HD/#references","text":"Wikipedia Zune HD","title":"References"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/","text":"CE 6.0 Architecture System Files/Components K.xxx.DLL These DLLs reflect the same DLLs without the K in front of it, but live in Kernel space. This way when porting old drivers from Windows CE 5.0 (where all drivers lived in user mode) the code can simply call the same API, but it does not need to perform a context switch. User mode calls are handled by Coredll.dll and calls from processes running in kernel mode are redirected to Kernel.DLL by K.Coredll.DLL so that the call stays in the same VM. This way the calls are way faster compared to Windows CE 5.0. Any DLL that is use by both kernel-mode and user-mode processes will be loaded as both kernel-mode and user-mode. Services Services run in user-mode and are handled by the Services Manager . Device Manager The Device.DLL runs in kernel-mode and loads the device drivers. It supports loading drivers on boot or on demand. Windows also provides a user-mode Device Manager for drivers installed after shipping for example. NK.EXE This used to be the kernel, but now it just contains a thin abstraction layer and compatibility layer, provided by the OEM. The actual Kernel now lives in Kernel.DLL . Security Windows CE 6.0 removed both the \"all kernel mode\" (running everything in kernel mode) feature and the trusted model (trusted and untrusted .EXEs and DLLs). It also does not have the Access Control List of newer desktop systems. The system also provides a separate handle table for each process. GWES GWES provides graphical functionality. Memory Layout Microsoft - Memory Layout References Microsoft - Windows Embedded CE 6.0 Advanced Memory Management Microsoft - Windows Embedded CE Architecture \ud83d\uddfa\ufe0f Windows CE 6.0","title":"CE 6.0 Architecture"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#ce-60-architecture","text":"","title":"CE 6.0 Architecture"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#system-filescomponents","text":"","title":"System Files/Components"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#kxxxdll","text":"These DLLs reflect the same DLLs without the K in front of it, but live in Kernel space. This way when porting old drivers from Windows CE 5.0 (where all drivers lived in user mode) the code can simply call the same API, but it does not need to perform a context switch. User mode calls are handled by Coredll.dll and calls from processes running in kernel mode are redirected to Kernel.DLL by K.Coredll.DLL so that the call stays in the same VM. This way the calls are way faster compared to Windows CE 5.0. Any DLL that is use by both kernel-mode and user-mode processes will be loaded as both kernel-mode and user-mode.","title":"K.xxx.DLL"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#services","text":"Services run in user-mode and are handled by the Services Manager .","title":"Services"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#device-manager","text":"The Device.DLL runs in kernel-mode and loads the device drivers. It supports loading drivers on boot or on demand. Windows also provides a user-mode Device Manager for drivers installed after shipping for example.","title":"Device Manager"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#nkexe","text":"This used to be the kernel, but now it just contains a thin abstraction layer and compatibility layer, provided by the OEM. The actual Kernel now lives in Kernel.DLL .","title":"NK.EXE"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#security","text":"Windows CE 6.0 removed both the \"all kernel mode\" (running everything in kernel mode) feature and the trusted model (trusted and untrusted .EXEs and DLLs). It also does not have the Access Control List of newer desktop systems. The system also provides a separate handle table for each process.","title":"Security"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#gwes","text":"GWES provides graphical functionality.","title":"GWES"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#memory-layout","text":"Microsoft - Memory Layout","title":"Memory Layout"},{"location":"Zune%20devices/Zune%20HD/CE%206.0%20Architecture/#references","text":"Microsoft - Windows Embedded CE 6.0 Advanced Memory Management Microsoft - Windows Embedded CE Architecture \ud83d\uddfa\ufe0f Windows CE 6.0","title":"References"},{"location":"Zune%20devices/Zune%20HD/Device%20Manager/","text":"Device Manger The device manager loads device drivers and manages their resources. Security Taken from Microsoft - Device Manager Security : In Windows Embedded CE 6.0, the kernel performs a full access check on first level buffer pointer parameters. This access check eliminates the need for validation to be performed by the device driver. However, a driver must still verify that the caller has access to memory addressed by embedded pointers using CeOpenCallerBuffer and CeCloseCallerBuffer . For additional information, see the Migrating a Windows Embedded CE Driver to Windows Embedded CE 6.0 . References Microsoft - Device Manager Architecture Microsoft - Device Manager Security \ud83d\uddfa\ufe0f Windows CE 6.0","title":"Device Manger"},{"location":"Zune%20devices/Zune%20HD/Device%20Manager/#device-manger","text":"The device manager loads device drivers and manages their resources.","title":"Device Manger"},{"location":"Zune%20devices/Zune%20HD/Device%20Manager/#security","text":"Taken from Microsoft - Device Manager Security : In Windows Embedded CE 6.0, the kernel performs a full access check on first level buffer pointer parameters. This access check eliminates the need for validation to be performed by the device driver. However, a driver must still verify that the caller has access to memory addressed by embedded pointers using CeOpenCallerBuffer and CeCloseCallerBuffer . For additional information, see the Migrating a Windows Embedded CE Driver to Windows Embedded CE 6.0 .","title":"Security"},{"location":"Zune%20devices/Zune%20HD/Device%20Manager/#references","text":"Microsoft - Device Manager Architecture Microsoft - Device Manager Security \ud83d\uddfa\ufe0f Windows CE 6.0","title":"References"},{"location":"Zune%20devices/Zune%20HD/Exploits/","text":"Exploits There are a few known exploits for the Zune HD, each with varying capabilities. So far, no exploits have been discovered that allow for custom firmware or persistent modifications. OpenZDK OpenZDK contains the earliest known exploit for the Zune, leveraging a bug in the shell to obtain arbitrary code execution within the app sandbox. This allows for the development of Zune apps that are not limited by XNA Framework or .NET Compact Framework 3.5. Zuneslayer Zuneslayer by Argonaut CUB3D is a suite of exploits for various Zune models, two of which target the HD. Kernel This is an exploit for firmware 4.5 built on OpenZDK to gain native code execution at the kernel level. It cannot be used to dump the full bootROM. When launched using the typical XNA loader, it cannot be used to read encrypted apps or DRM-protected media. Browser This is an exploit of the Zune's JScript engine based on CVE-2019-1367 . It can be used to launch other programs from outside the app sandbox and is a suitable alternative to the offical XNA loader. Programs launched using this technique can read encrypted apps and DRM-protected media. The exploit by default loads whatever file is located at \\\\Flash2\\payload.exe . Typically, the \\\\Flash2 directory is inaccessible, but the Zuneslayer kernel exploit provides suffcient permissions to write files there. The browser exploit can be chained with kernel exploit as follows: Use the zuneslayer_kernel template to create the payload you wish to run with kernel permissions. Install the kernel exploit app as you would any other OpenZDK app. Open the kernel exploit app. If you used the template, it will automatically copy nativeapp to \\\\Flash2\\payload.exe . Serve index.html on a machine accessible from the Zune HD. For example, running an Apache web server on a machine in the same local network. Visit the hosted page from the Zune HD browser and follow the on-screen instructions. For applications that require reading DRM-protected content, the Zune must be restarted before the required permissions are granted. Fus\u00e9e Gel\u00e9e It is believed that the Tegra APX 2600 used in the Zune HD is vulnerable to an attack similar to CVE-2018-6242, also known as Fus\u00e9e Gel\u00e9e . Theoretically, an attacker with physical access to a Zune in Tegra Recovery Mode (RCM) could execute arbitrary code as the root of trust. This exploit has yet to be carried out on a Zune, since getting an HD into RCM is tricky. Any of the following conditions may trigger RCM as observed on other Tegra processors \u00b9 : If the processor fails to find a valid Boot Control Table (BCT) + bootloader on its boot media If processor straps are pulled to a particular value e.g. by holding a button combination If the processor is rebooted after a particular value is written into a power management controller scratch register. One Argonaut was able to intentionally enter RCM by desoldering the bootROM flash chip, which triggers the third condition. Other users during Zune's lifetime reported their HDs suddenly entering RCM and appearing to Windows as \"APX\" \u00b2 , though no cause is known.","title":"Exploits"},{"location":"Zune%20devices/Zune%20HD/Exploits/#exploits","text":"There are a few known exploits for the Zune HD, each with varying capabilities. So far, no exploits have been discovered that allow for custom firmware or persistent modifications.","title":"Exploits"},{"location":"Zune%20devices/Zune%20HD/Exploits/#openzdk","text":"OpenZDK contains the earliest known exploit for the Zune, leveraging a bug in the shell to obtain arbitrary code execution within the app sandbox. This allows for the development of Zune apps that are not limited by XNA Framework or .NET Compact Framework 3.5.","title":"OpenZDK"},{"location":"Zune%20devices/Zune%20HD/Exploits/#zuneslayer","text":"Zuneslayer by Argonaut CUB3D is a suite of exploits for various Zune models, two of which target the HD.","title":"Zuneslayer"},{"location":"Zune%20devices/Zune%20HD/Exploits/#kernel","text":"This is an exploit for firmware 4.5 built on OpenZDK to gain native code execution at the kernel level. It cannot be used to dump the full bootROM. When launched using the typical XNA loader, it cannot be used to read encrypted apps or DRM-protected media.","title":"Kernel"},{"location":"Zune%20devices/Zune%20HD/Exploits/#browser","text":"This is an exploit of the Zune's JScript engine based on CVE-2019-1367 . It can be used to launch other programs from outside the app sandbox and is a suitable alternative to the offical XNA loader. Programs launched using this technique can read encrypted apps and DRM-protected media. The exploit by default loads whatever file is located at \\\\Flash2\\payload.exe . Typically, the \\\\Flash2 directory is inaccessible, but the Zuneslayer kernel exploit provides suffcient permissions to write files there. The browser exploit can be chained with kernel exploit as follows: Use the zuneslayer_kernel template to create the payload you wish to run with kernel permissions. Install the kernel exploit app as you would any other OpenZDK app. Open the kernel exploit app. If you used the template, it will automatically copy nativeapp to \\\\Flash2\\payload.exe . Serve index.html on a machine accessible from the Zune HD. For example, running an Apache web server on a machine in the same local network. Visit the hosted page from the Zune HD browser and follow the on-screen instructions. For applications that require reading DRM-protected content, the Zune must be restarted before the required permissions are granted.","title":"Browser"},{"location":"Zune%20devices/Zune%20HD/Exploits/#fusee-gelee","text":"It is believed that the Tegra APX 2600 used in the Zune HD is vulnerable to an attack similar to CVE-2018-6242, also known as Fus\u00e9e Gel\u00e9e . Theoretically, an attacker with physical access to a Zune in Tegra Recovery Mode (RCM) could execute arbitrary code as the root of trust. This exploit has yet to be carried out on a Zune, since getting an HD into RCM is tricky. Any of the following conditions may trigger RCM as observed on other Tegra processors \u00b9 : If the processor fails to find a valid Boot Control Table (BCT) + bootloader on its boot media If processor straps are pulled to a particular value e.g. by holding a button combination If the processor is rebooted after a particular value is written into a power management controller scratch register. One Argonaut was able to intentionally enter RCM by desoldering the bootROM flash chip, which triggers the third condition. Other users during Zune's lifetime reported their HDs suddenly entering RCM and appearing to Windows as \"APX\" \u00b2 , though no cause is known.","title":"Fus\u00e9e Gel\u00e9e"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/","text":"Reproduced from NH Switch Guide ( repo ) Fus\u00e9e Gel\u00e9e This report documents Fus\u00e9e Gel\u00e9e, a coldboot vulnerability that allows full, unauthenticated arbitrary code execution from an early bootROM context via Tegra Recovery Mode (RCM) on NVIDIA's Tegra line of embedded processors. As this vulnerability allows arbitrary code execution on the Boot and Power Management Processor (BPMP) before any lock-outs take effect, this vulnerability compromises the entire root-of-trust for each processor, and allows exfiltration of secrets e.g. burned into device fuses. Quick vitals: Reporter: Katherine Temkin (@ktemkin) Affiliation: ReSwitched (https://reswitched.tech) E-mail: k@ktemkin.com Affects: Tegra SoCs, independent of software stack Versions: believed to affect Tegra SoCs released prior to the T186 / X2 Impact: early bootROM code execution with no software requirements, which can lead to full compromise of on-device secrets where USB access is possible Disclosure public disclosure planned for June 15th, 2018 Vulnerability Summary The USB software stack provided inside the boot instruction rom (IROM/bootROM) contains a copy operation whose length can be controlled by an attacker. By carefully constructing a USB control request, an attacker can leverage this vulnerability to copy the contents of an attacker-controlled buffer over the active execution stack, gaining control of the Boot and Power Management processor (BPMP) before any lock-outs or privilege reductions occur. This execution can then be used to exfiltrate secrets and to load arbitrary code onto the main CPU Complex (CCPLEX) \"application processors\" at the highest possible level of privilege (typically as the TrustZone Secure Monitor at PL3/EL3). Public Disclosure Notice This vulnerability is notable due to the significant number and variety of devices affected, the severity of the issue, and the immutability of the relevant code on devices already delivered to end users. This vulnerability report is provided as a courtesy to help aid remediation efforts, guide communication, and minimize impact to users. As other groups appear to have this or an equivalent exploit-- including a group who claims they will be selling access to an implementation of such an exploit -- it is the author and the ReSwitched team's belief that prompt public disclosure best serves the public interest. By minimizing the information asymmetry between the general public and exploit-holders and notifying the public, users will be able to best assess how this vulnerability impacts their personal threat models. Accordingly, ReSwitched anticipates public disclosure of this vulnerability: If another group releases an implementation of the identified vulnerability; or On June 15th, 2018, whichever comes first. Vulnerability Details The core of the Tegra boot process is approximated by the following block of pseudo-code, as obtained by reverse-engineering an IROM extracted from a vulnerable T210 system: // If this is a warmboot (from \"sleep\"), restore the saved state from RAM. if ( read_scratch0_bit ( 1 )) { restore_warmboot_image ( & load_addr ); } // Otherwise, bootstrap the processor. else { // Allow recovery mode to be forced by a PMC scratch bit or physical straps. force_recovery = check_for_rcm_straps () || read_scratch0_bit ( 2 ); // Determine whether to use USB2 or USB3 for RCM. determine_rcm_usb_version ( & usb_version ); usb_ops = set_up_usb_ops ( usb_version ); usb_ops -> initialize (); // If we're not forcing recovery, attempt to load an image from boot media. if ( ! force_recovery ) { // If we succeeded, don't fall back into recovery mode. if ( read_boot_configuration_and_images ( & load_addr ) == SUCCESS ) { goto boot_complete ; } } // In all other conditions if ( read_boot_images_via_usb_rcm ( < snip > , & load_addr ) != SUCCESS ) { /* load address is poisoned here */ } } boot_complete : /* apply lock-outs, and boot the program at address load_address */ Tegra processors include a USB Recovery Mode (RCM), which we can observe to be activated under a number of conditions: If the processor fails to find a valid Boot Control Table (BCT) + bootloader on its boot media; If processor straps are pulled to a particular value e.g. by holding a button combination; or If the processor is rebooted after a particular value is written into a power management controller scratch register. USB recovery mode is present in all devices, including devices that have been production secured. To ensure that USB recovery mode does not allow unauthenticated communications, RCM requires all recovery commands be signed using either RSA or via AES-CMAC. The bootloader's implementation of the Tegra RCM protocol is simple, and exists to allow loading a small piece of code (called the miniloader or applet ) into the bootloader's local Instruction RAM (IRAM). In a typical application, this applet is nvtboot-recovery , a stub which allows further USB communications to bootstrap a system or to allow system provisioning. The RCM process is approximated by the following pseudo-code, again obtained via reverse engineering a dumped IROM from a T210: // Significantly simplified for clarity, with error checking omitted where unimportant. while ( 1 ) { // Repeatedly handle USB standard events on the control endpoint EP0. usb_ops -> handle_control_requests ( current_dma_buffer ); // Try to send the device ID over the main USB data pipe until we succeed. if ( rcm_send_device_id () == USB_NOT_CONFIGURED ) { usb_initialized = 0 ; } // Once we've made a USB connection, accept RCM commands on EP1. else { usb_initialized = 1 ; // Read a full RCM command and any associated payload into a global buffer. // (Error checking omitted for brevity.) rcm_read_command_and_payload (); // Validate the received RCM command; e.g. by checking for signatures // in RSA or AES_CMAC mode, or by trivially succeeding if we're not in // a secure mode. rc = rcm_validate_command (); if ( rc != VALIDATION_PASS ) { return rc ; } // Handle the received and validated command. // For a \"load miniloader\" command, this sanity checks the (validated) // miniloader image and takes steps to prevent re-use of signed data not // intended to be used as an RCM command. rcm_handle_command_complete (...); } } It is important to note that a full RCM command and its associated payload are read into 1) a global buffer, and 2) the target load address, respectively, before any signature checking is done. This effectively grants the attacker a narrow window in which they control a large region of unvalidated memory. The largest vulnerability surface area occurs in the rcm_read_command_and_payload function, which accepts the RCM command and payload packets via a USB bulk endpoint. For our purposes, this endpoint is essentially a simple pipe for conveyance of blocks of binary data separate from standard USB communications. The rcm_read_command_and_payload function actually contains several issues-- of which exactly one is known to be exploitable: uint32_t total_rxd = 0 ; uint32_t total_to_rx = 0x400 ; // Loop until we've received our full command and payload. while ( total_rxd < total_to_rx ) { // Switch between two DMA buffers, so the USB is never DMA'ing into the same // buffer that we're processing. active_buffer = next_buffer ; next_buffer = switch_dma_buffers (); // Start a USB DMA transaction on the RCM bulk endpoint, which will hopefully // receive data from the host in the background as we copy. usb_ops -> start_nonblocking_bulk_read ( active_buffer , 0x1000 ); // If we're in the first 680-bytes we're receiving, this is part of the RCM // command, and we should read it into the command buffer. if ( total_rxd < 680 ) { /* copy data from the DMA buffer into the RCM command buffer until we've read a full 680-byte RCM command */ // Once we've received the first four bytes of the RCM command, // use that to figure out how much data should be received. if ( total_rxd >= 4 ) { // validate: // -- the command won't exceed our total RAM // (680 here, 0x30000 in upper IRAM) // -- the command is >= 0x400 bytes // -- the size ends in 8 if ( rcm_command_buffer [ 0 ] >= 0x302A8u || rcm_command_buffer [ 0 ] < 0x400u || ( rcm_command_buffer [ 0 ] & 0xF ) != 8 ) { return ERROR_INVALID_SIZE ; } else { left_to_rx = * (( uint32_t * ) rcm_command_buffer ); } } } /* copy any data _past_ the command into a separate payload buffer at 0x40010000 */ /* -code omitted for brevity - */ // Wait for the DMA transaction to complete. // [This is, again, simplified to convey concepts.] while ( ! usb_ops -> bulk_read_complete ()) { // While we're blocking, it's still important that we respond to standard // USB packets on the control endpoint, so do that here. usb_ops -> handle_control_requests ( next_buffer ); } } Astute readers will notice an issue unrelated to the Fus\u00e9e Gel\u00e9e exploit: this code fails to properly ensure DMA buffers are being used exclusively for a single operation. This results in an interesting race condition in which a DMA buffer can be simultaneously used to handle a control request and a RCM bulk transfer. This can break the flow of RCM, but as both operations contain untrusted data, this issue poses no security risk. To find the actual vulnerability, we must delve deeper, into the code that handles standard USB control requests. The core of this code is responsible for responding to USB control requests. A control request is initiated when the host sends a setup packet, of the following form: Field Size Description direction 1b if '1', the device should respond with data type 2b specifies whether this request is of a standard type or not recipient 5b encodes the context in which this request should be considered; for example, is this about a DEVICE or about an ENDPOINT ? request 8b specifies the request number value 16b argument to the request index 16b argument to the request length 16b specifies the maximum amount of data to be transferred As an example, the host can request the status of a device by issuing a GET_STATUS request, at which point the device would be expected to respond with a short setup packet. Of particular note is the length field of the request, which should limit -- but not exclusively determine-- the maximum amount of data that should be included in the response. Per the specification, the device should respond with either the amount of data specified or the amount of data available , whichever is less. The bootloader's implementation of this behavior is conceptually implemented as follows: // Temporary, automatic variables, located on the stack. uint16_t status ; void * data_to_tx ; // The amount of data available to transmit. uint16_t size_to_tx = 0 ; // The amount of data the USB host requested. uint16_t length_read = setup_packet . length ; /* Lots of handler cases have omitted for brevity. */ // Handle GET_STATUS requests. if ( setup_packet . request == REQUEST_GET_STATUS ) { // If this is asking for the DEVICE's status, respond accordingly. if ( setup_packet . recipient == RECIPIENT_DEVICE ) { status = get_usb_device_status (); size_to_tx = sizeof ( status ); } // Otherwise, respond with the ENDPOINT status. else if ( setup_packet . recipient == RECIPIENT_ENDPOINT ){ status = get_usb_endpoint_status ( setup_packet . index ); size_to_tx = length_read ; // <-- This is a critical error! } else { /* ... */ } // Send the status value, which we'll copy from the stack variable 'status'. data_to_tx = & status ; } // Copy the data we have into our DMA buffer for transmission. // For a GET_STATUS request, this copies data from the stack into our DMA buffer. memcpy ( dma_buffer , data_to_tx , size_to_tx ); // If the host requested less data than we have, only send the amount requested. // This effectively selects min(size_to_tx, length_read). if ( length_read < size_to_tx ) { size_to_tx = length_read ; } // Transmit the response we've constructed back to the host. respond_to_control_request ( dma_buffer , length_to_send ); In most cases, the handler correctly limits the length of the transmitted responses to the amount it has available, per the USB specification. However, in a few notable cases, the length is incorrectly always set to the amount requested by the host: When issuing a GET_CONFIGURATION request with a DEVICE recipient. When issuing a GET_INTERFACE request with a INTERFACE recipient. When issuing a GET_STATUS request with a ENDPOINT recipient. This is a critical security error, as the host can request up to 65,535 bytes per control request. In cases where this is loaded directly into size_to_tx , this value directly sets the extent of the memcpy that follows-- and thus can copy up to 65,535 bytes into the currently selected dma_buffer . As the DMA buffers used for the USB stack are each comparatively short, this can result in a very significant buffer overflow. To validate that the vulnerability is present on a given device, one can try issuing an oversized request and watch as the device responds. Pictured below is the response generated when sending a oversized GET_STATUS control request with an ENDPOINT recipient to a T124: A compliant device should generate a two-byte response to a GET_STATUS request-- but the affected Tegra responds with significantly longer response. This is a clear indication that we've run into the vulnerability described above. To really understand the impact of this vulnerability, it helps to understand the memory layout used by the bootROM. For our proof-of-concept, we'll consider the layout used by the T210 variant of the affected bootROM: The major memory regions relevant to this vulnerability are as follows: The bootROM's execution stack grows downward from 0x40010000 ; so the execution stack is located in the memory immediately preceding that address. The DMA buffers used for USB are located at 0x40005000 and 0x40009000 , respectively. Because the USB stack alternates between these two buffers once per USB transfer, the host effectively can control which DMA buffer is in use by sending USB transfers. Once the bootloader's RCM code receives a 680-byte command, it begins to store received data in a section of upper IRAM located at address 0x40010000 , and can store up to 0x30000 bytes of payload. This address is notable, as it is immediately past the end of the active execution stack. Of particular note is the adjacency of the bootROM's execution stack and the attacker-controlled RCM payload . Consider the behavior of the previous pseudo-code segment on receipt of a GET_STATUS request to the ENDPOINT with an excessive length. The resulting memcpy: copies up to 65,535 bytes total; sources data from a region starting at the status variable on the stack and extending significantly past the stack -- effectively copying mostly from the attacker-controllable RCM payload buffer targets a buffer starting either 0x40005000 or 0x40009000 , at the attacker's discretion, reaching addresses of up to 0x40014fff or 0x40018fff This is a powerful copy primitive, as it copies from attacker controlled memory and into a region that includes the entire execution stack : This would be a powerful exploit on any platform; but this is a particularly devastating attack in the bootROM environment, which does not: Use common attack mitigations such as stack canaries, ostensibly to reduce complexity and save limited IRAM and IROM space. Apply memory protections, so the entire stack and all attacker controlled buffers can be read from, written to, and executed from. Employ typical 'application-processor' mitigation strategies such as ASLR. Accordingly, we now have: The capability to load arbitrary payloads into memory via RCM, as RCM only validates command signatures once payload receipt is complete. The ability to copy attacker-controlled values over the execution stack, overwriting return addresses and redirecting execution to a location of our choice. Together, these two abilities give us a full arbitrary-code execution exploit at a critical point in the Tegra's start-up process. As control flow is hijacked before return from read_boot_images_via_usb_rcm , none of the \"lock-out\" operations that precede normal startup are executed. This means, for example, that the T210 fuses-- and the keydata stored within them-- are accessible from the attack payload, and the bootROM is not yet protected. Exploit Execution The Fus\u00e9e Launcher PoC exploits the vulnerability described on the T210 via a careful sequence of interactions: The device is started in RCM mode. Device specifics will differ, but this is often via a key-combination held on startup. A host computer is allowed to enumerate the RCM device normally. The host reads the RCM device's ID by reading 16 bytes from the EP1 IN. The host builds an exploit payload, which is comprised of: An RCM command that includes a maximum length, ensuring that we can send as much payload as possible without completing receipt of the RCM payload. Only the length of this command is used prior to validation; so we can submit an RCM command that starts with a maximum length of 0x30298, but which fills the remaining 676 bytes of the RCM command with any value. A set of values with which to overwrite the stack. As stack return address locations vary across the series, it's recommended that a large block composed of a single entry-point address be repeated a significant number of times, so one can effectively replace the entire stack with that address. The program to be executed (\"final payload\") is appended, ensuring that its position in the binary matches the entry-point from the previous step. The payload is padded to be evenly divisible by the 0x1000 block size to ensure the active block is not overwritten by the \"DMA dual-use\" bug described above. The exploit payload is sent to the device over EP1 OUT, tracking the number of 0x1000-byte \"blocks\" that have been sent to the device. If this number is even , the next write will be issued to the lower DMA buffer ( 0x40005000 ); otherwise, it will be issued to the upper DMA buffer ( 0x40009000 ). If the next write would target the lower DMA buffer, issue another write of a full 0x1000 bytes to move the target to the upper DMA buffer, reducing the total amount of data to be copied. Trigger the vulnerable memcpy by sending a GET_STATUS IN control request with an ENDPOINT recipient, and a length long enough to smash the desired stack region, and preferably not longer than required. A simple host program that triggers this vulnerability is included with this report: see fusee-launcher.py . Note the restrictions on its function in the following section. Proof of Concept Included with this report is a set of three files: fusee-launcher.py -- The main proof-of-concept accompanying this report. This python script is designed to launch a simple binary payload in the described bootROM context via the exploit. intermezzo.bin -- This small stub is designed to relocate a payload from a higher load address to the standard RCM load address of 0x40010000 . This allows standard RCM payloads (such as nvtboot-recover.bin ) to be executed. fusee.bin -- An example payload for the Nintendo Switch, a representative and well-secured device based on a T210. This payload will print information from the device's fuses and protected IROM to the display, demonstrating that early bootROM execution has been achieved. Support note: Many host-OS driver stacks are reluctant to issue unreasonably large control requests. Accordingly, the current proof-of-concept includes code designed to work in the following environments: 64-bit linux via xhci_hcd . The proof-of-concept can manually submit large control requests, but does not work with the common ehci_hcd drivers due to driver limitations. A rough rule of thumb is that a connection via a blue / USB3 SuperSpeed port will almost always be handled by xhci_hcd . macOS . The exploit works out of the box with no surprises or restrictions on modern macOS. Windows support would require addition of a custom kernel module, and thus was beyond the scope of a simple proof-of-concept. To use this proof-of-concept on a Nintendo Switch: Set up an Linux or macOS environment that meets the criteria above, and which has a working python3 and pyusb as well as libusb installed. Connect the Switch to your host PC with a USB A -> USB C cable. Boot the Switch in RCM mode. There are three ways to do this, but the first-- unseating its eMMC board-- is likely the most straightforward: Ensure the Switch cannot boot off its eMMC. The most straightforward way to to this is to open the back cover and remove the socketed eMMC board; corrupting the BCT or bootloader on the eMMC boot partition would also work. Trigger the RCM straps. Hold VOL_UP and short pin 10 on the right JoyCon connector to ground while engaging the power button. Set bit 2 of PMC scratch register zero. On modern firmwares, this requires EL3 or pre-sleep BPMP execution. Run the fusee-launcher.py with an argument of fusee.bin . (This requires intermezzo.bin to be located in the same folder as fusee-launcher.py .) sudo python3 ./fusee-launcher.py fusee.bin If everything functions correctly, your Switch should be displaying a collection of fuse and protected-IROM information: Recommended Mitigations In this case, the recommended mitigation is to correct the USB control request handler such that it always correctly constrains the length to be transmitted. This has to be handled according to the type of device: For a device already in consumer hands , no solution is proposed. Unfortunately, access to the fuses needed to configure the device's ipatches was blocked when the ODM_PRODUCTION fuse was burned, so no bootROM update is possible. It is suggested that consumers be made aware of the situation so they can move to other devices, where possible. For new devices , the correct solution is likely to introduce an new ipatch or new ipatches that limits the size of control request responses. It seems likely that OEMs producing T210-based devices may move to T214 solutions; it is the hope of the author that the T214's bootROM shares immunity with the T186. If not, patching the above is a recommended modification to the mask ROM and/or ipatches of the T214, as well.","title":"Fusee Gelee"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/#fusee-gelee","text":"This report documents Fus\u00e9e Gel\u00e9e, a coldboot vulnerability that allows full, unauthenticated arbitrary code execution from an early bootROM context via Tegra Recovery Mode (RCM) on NVIDIA's Tegra line of embedded processors. As this vulnerability allows arbitrary code execution on the Boot and Power Management Processor (BPMP) before any lock-outs take effect, this vulnerability compromises the entire root-of-trust for each processor, and allows exfiltration of secrets e.g. burned into device fuses. Quick vitals: Reporter: Katherine Temkin (@ktemkin) Affiliation: ReSwitched (https://reswitched.tech) E-mail: k@ktemkin.com Affects: Tegra SoCs, independent of software stack Versions: believed to affect Tegra SoCs released prior to the T186 / X2 Impact: early bootROM code execution with no software requirements, which can lead to full compromise of on-device secrets where USB access is possible Disclosure public disclosure planned for June 15th, 2018","title":"Fus\u00e9e Gel\u00e9e"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/#vulnerability-summary","text":"The USB software stack provided inside the boot instruction rom (IROM/bootROM) contains a copy operation whose length can be controlled by an attacker. By carefully constructing a USB control request, an attacker can leverage this vulnerability to copy the contents of an attacker-controlled buffer over the active execution stack, gaining control of the Boot and Power Management processor (BPMP) before any lock-outs or privilege reductions occur. This execution can then be used to exfiltrate secrets and to load arbitrary code onto the main CPU Complex (CCPLEX) \"application processors\" at the highest possible level of privilege (typically as the TrustZone Secure Monitor at PL3/EL3).","title":"Vulnerability Summary"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/#public-disclosure-notice","text":"This vulnerability is notable due to the significant number and variety of devices affected, the severity of the issue, and the immutability of the relevant code on devices already delivered to end users. This vulnerability report is provided as a courtesy to help aid remediation efforts, guide communication, and minimize impact to users. As other groups appear to have this or an equivalent exploit-- including a group who claims they will be selling access to an implementation of such an exploit -- it is the author and the ReSwitched team's belief that prompt public disclosure best serves the public interest. By minimizing the information asymmetry between the general public and exploit-holders and notifying the public, users will be able to best assess how this vulnerability impacts their personal threat models. Accordingly, ReSwitched anticipates public disclosure of this vulnerability: If another group releases an implementation of the identified vulnerability; or On June 15th, 2018, whichever comes first.","title":"Public Disclosure Notice"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/#vulnerability-details","text":"The core of the Tegra boot process is approximated by the following block of pseudo-code, as obtained by reverse-engineering an IROM extracted from a vulnerable T210 system: // If this is a warmboot (from \"sleep\"), restore the saved state from RAM. if ( read_scratch0_bit ( 1 )) { restore_warmboot_image ( & load_addr ); } // Otherwise, bootstrap the processor. else { // Allow recovery mode to be forced by a PMC scratch bit or physical straps. force_recovery = check_for_rcm_straps () || read_scratch0_bit ( 2 ); // Determine whether to use USB2 or USB3 for RCM. determine_rcm_usb_version ( & usb_version ); usb_ops = set_up_usb_ops ( usb_version ); usb_ops -> initialize (); // If we're not forcing recovery, attempt to load an image from boot media. if ( ! force_recovery ) { // If we succeeded, don't fall back into recovery mode. if ( read_boot_configuration_and_images ( & load_addr ) == SUCCESS ) { goto boot_complete ; } } // In all other conditions if ( read_boot_images_via_usb_rcm ( < snip > , & load_addr ) != SUCCESS ) { /* load address is poisoned here */ } } boot_complete : /* apply lock-outs, and boot the program at address load_address */ Tegra processors include a USB Recovery Mode (RCM), which we can observe to be activated under a number of conditions: If the processor fails to find a valid Boot Control Table (BCT) + bootloader on its boot media; If processor straps are pulled to a particular value e.g. by holding a button combination; or If the processor is rebooted after a particular value is written into a power management controller scratch register. USB recovery mode is present in all devices, including devices that have been production secured. To ensure that USB recovery mode does not allow unauthenticated communications, RCM requires all recovery commands be signed using either RSA or via AES-CMAC. The bootloader's implementation of the Tegra RCM protocol is simple, and exists to allow loading a small piece of code (called the miniloader or applet ) into the bootloader's local Instruction RAM (IRAM). In a typical application, this applet is nvtboot-recovery , a stub which allows further USB communications to bootstrap a system or to allow system provisioning. The RCM process is approximated by the following pseudo-code, again obtained via reverse engineering a dumped IROM from a T210: // Significantly simplified for clarity, with error checking omitted where unimportant. while ( 1 ) { // Repeatedly handle USB standard events on the control endpoint EP0. usb_ops -> handle_control_requests ( current_dma_buffer ); // Try to send the device ID over the main USB data pipe until we succeed. if ( rcm_send_device_id () == USB_NOT_CONFIGURED ) { usb_initialized = 0 ; } // Once we've made a USB connection, accept RCM commands on EP1. else { usb_initialized = 1 ; // Read a full RCM command and any associated payload into a global buffer. // (Error checking omitted for brevity.) rcm_read_command_and_payload (); // Validate the received RCM command; e.g. by checking for signatures // in RSA or AES_CMAC mode, or by trivially succeeding if we're not in // a secure mode. rc = rcm_validate_command (); if ( rc != VALIDATION_PASS ) { return rc ; } // Handle the received and validated command. // For a \"load miniloader\" command, this sanity checks the (validated) // miniloader image and takes steps to prevent re-use of signed data not // intended to be used as an RCM command. rcm_handle_command_complete (...); } } It is important to note that a full RCM command and its associated payload are read into 1) a global buffer, and 2) the target load address, respectively, before any signature checking is done. This effectively grants the attacker a narrow window in which they control a large region of unvalidated memory. The largest vulnerability surface area occurs in the rcm_read_command_and_payload function, which accepts the RCM command and payload packets via a USB bulk endpoint. For our purposes, this endpoint is essentially a simple pipe for conveyance of blocks of binary data separate from standard USB communications. The rcm_read_command_and_payload function actually contains several issues-- of which exactly one is known to be exploitable: uint32_t total_rxd = 0 ; uint32_t total_to_rx = 0x400 ; // Loop until we've received our full command and payload. while ( total_rxd < total_to_rx ) { // Switch between two DMA buffers, so the USB is never DMA'ing into the same // buffer that we're processing. active_buffer = next_buffer ; next_buffer = switch_dma_buffers (); // Start a USB DMA transaction on the RCM bulk endpoint, which will hopefully // receive data from the host in the background as we copy. usb_ops -> start_nonblocking_bulk_read ( active_buffer , 0x1000 ); // If we're in the first 680-bytes we're receiving, this is part of the RCM // command, and we should read it into the command buffer. if ( total_rxd < 680 ) { /* copy data from the DMA buffer into the RCM command buffer until we've read a full 680-byte RCM command */ // Once we've received the first four bytes of the RCM command, // use that to figure out how much data should be received. if ( total_rxd >= 4 ) { // validate: // -- the command won't exceed our total RAM // (680 here, 0x30000 in upper IRAM) // -- the command is >= 0x400 bytes // -- the size ends in 8 if ( rcm_command_buffer [ 0 ] >= 0x302A8u || rcm_command_buffer [ 0 ] < 0x400u || ( rcm_command_buffer [ 0 ] & 0xF ) != 8 ) { return ERROR_INVALID_SIZE ; } else { left_to_rx = * (( uint32_t * ) rcm_command_buffer ); } } } /* copy any data _past_ the command into a separate payload buffer at 0x40010000 */ /* -code omitted for brevity - */ // Wait for the DMA transaction to complete. // [This is, again, simplified to convey concepts.] while ( ! usb_ops -> bulk_read_complete ()) { // While we're blocking, it's still important that we respond to standard // USB packets on the control endpoint, so do that here. usb_ops -> handle_control_requests ( next_buffer ); } } Astute readers will notice an issue unrelated to the Fus\u00e9e Gel\u00e9e exploit: this code fails to properly ensure DMA buffers are being used exclusively for a single operation. This results in an interesting race condition in which a DMA buffer can be simultaneously used to handle a control request and a RCM bulk transfer. This can break the flow of RCM, but as both operations contain untrusted data, this issue poses no security risk. To find the actual vulnerability, we must delve deeper, into the code that handles standard USB control requests. The core of this code is responsible for responding to USB control requests. A control request is initiated when the host sends a setup packet, of the following form: Field Size Description direction 1b if '1', the device should respond with data type 2b specifies whether this request is of a standard type or not recipient 5b encodes the context in which this request should be considered; for example, is this about a DEVICE or about an ENDPOINT ? request 8b specifies the request number value 16b argument to the request index 16b argument to the request length 16b specifies the maximum amount of data to be transferred As an example, the host can request the status of a device by issuing a GET_STATUS request, at which point the device would be expected to respond with a short setup packet. Of particular note is the length field of the request, which should limit -- but not exclusively determine-- the maximum amount of data that should be included in the response. Per the specification, the device should respond with either the amount of data specified or the amount of data available , whichever is less. The bootloader's implementation of this behavior is conceptually implemented as follows: // Temporary, automatic variables, located on the stack. uint16_t status ; void * data_to_tx ; // The amount of data available to transmit. uint16_t size_to_tx = 0 ; // The amount of data the USB host requested. uint16_t length_read = setup_packet . length ; /* Lots of handler cases have omitted for brevity. */ // Handle GET_STATUS requests. if ( setup_packet . request == REQUEST_GET_STATUS ) { // If this is asking for the DEVICE's status, respond accordingly. if ( setup_packet . recipient == RECIPIENT_DEVICE ) { status = get_usb_device_status (); size_to_tx = sizeof ( status ); } // Otherwise, respond with the ENDPOINT status. else if ( setup_packet . recipient == RECIPIENT_ENDPOINT ){ status = get_usb_endpoint_status ( setup_packet . index ); size_to_tx = length_read ; // <-- This is a critical error! } else { /* ... */ } // Send the status value, which we'll copy from the stack variable 'status'. data_to_tx = & status ; } // Copy the data we have into our DMA buffer for transmission. // For a GET_STATUS request, this copies data from the stack into our DMA buffer. memcpy ( dma_buffer , data_to_tx , size_to_tx ); // If the host requested less data than we have, only send the amount requested. // This effectively selects min(size_to_tx, length_read). if ( length_read < size_to_tx ) { size_to_tx = length_read ; } // Transmit the response we've constructed back to the host. respond_to_control_request ( dma_buffer , length_to_send ); In most cases, the handler correctly limits the length of the transmitted responses to the amount it has available, per the USB specification. However, in a few notable cases, the length is incorrectly always set to the amount requested by the host: When issuing a GET_CONFIGURATION request with a DEVICE recipient. When issuing a GET_INTERFACE request with a INTERFACE recipient. When issuing a GET_STATUS request with a ENDPOINT recipient. This is a critical security error, as the host can request up to 65,535 bytes per control request. In cases where this is loaded directly into size_to_tx , this value directly sets the extent of the memcpy that follows-- and thus can copy up to 65,535 bytes into the currently selected dma_buffer . As the DMA buffers used for the USB stack are each comparatively short, this can result in a very significant buffer overflow. To validate that the vulnerability is present on a given device, one can try issuing an oversized request and watch as the device responds. Pictured below is the response generated when sending a oversized GET_STATUS control request with an ENDPOINT recipient to a T124: A compliant device should generate a two-byte response to a GET_STATUS request-- but the affected Tegra responds with significantly longer response. This is a clear indication that we've run into the vulnerability described above. To really understand the impact of this vulnerability, it helps to understand the memory layout used by the bootROM. For our proof-of-concept, we'll consider the layout used by the T210 variant of the affected bootROM: The major memory regions relevant to this vulnerability are as follows: The bootROM's execution stack grows downward from 0x40010000 ; so the execution stack is located in the memory immediately preceding that address. The DMA buffers used for USB are located at 0x40005000 and 0x40009000 , respectively. Because the USB stack alternates between these two buffers once per USB transfer, the host effectively can control which DMA buffer is in use by sending USB transfers. Once the bootloader's RCM code receives a 680-byte command, it begins to store received data in a section of upper IRAM located at address 0x40010000 , and can store up to 0x30000 bytes of payload. This address is notable, as it is immediately past the end of the active execution stack. Of particular note is the adjacency of the bootROM's execution stack and the attacker-controlled RCM payload . Consider the behavior of the previous pseudo-code segment on receipt of a GET_STATUS request to the ENDPOINT with an excessive length. The resulting memcpy: copies up to 65,535 bytes total; sources data from a region starting at the status variable on the stack and extending significantly past the stack -- effectively copying mostly from the attacker-controllable RCM payload buffer targets a buffer starting either 0x40005000 or 0x40009000 , at the attacker's discretion, reaching addresses of up to 0x40014fff or 0x40018fff This is a powerful copy primitive, as it copies from attacker controlled memory and into a region that includes the entire execution stack : This would be a powerful exploit on any platform; but this is a particularly devastating attack in the bootROM environment, which does not: Use common attack mitigations such as stack canaries, ostensibly to reduce complexity and save limited IRAM and IROM space. Apply memory protections, so the entire stack and all attacker controlled buffers can be read from, written to, and executed from. Employ typical 'application-processor' mitigation strategies such as ASLR. Accordingly, we now have: The capability to load arbitrary payloads into memory via RCM, as RCM only validates command signatures once payload receipt is complete. The ability to copy attacker-controlled values over the execution stack, overwriting return addresses and redirecting execution to a location of our choice. Together, these two abilities give us a full arbitrary-code execution exploit at a critical point in the Tegra's start-up process. As control flow is hijacked before return from read_boot_images_via_usb_rcm , none of the \"lock-out\" operations that precede normal startup are executed. This means, for example, that the T210 fuses-- and the keydata stored within them-- are accessible from the attack payload, and the bootROM is not yet protected.","title":"Vulnerability Details"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/#exploit-execution","text":"The Fus\u00e9e Launcher PoC exploits the vulnerability described on the T210 via a careful sequence of interactions: The device is started in RCM mode. Device specifics will differ, but this is often via a key-combination held on startup. A host computer is allowed to enumerate the RCM device normally. The host reads the RCM device's ID by reading 16 bytes from the EP1 IN. The host builds an exploit payload, which is comprised of: An RCM command that includes a maximum length, ensuring that we can send as much payload as possible without completing receipt of the RCM payload. Only the length of this command is used prior to validation; so we can submit an RCM command that starts with a maximum length of 0x30298, but which fills the remaining 676 bytes of the RCM command with any value. A set of values with which to overwrite the stack. As stack return address locations vary across the series, it's recommended that a large block composed of a single entry-point address be repeated a significant number of times, so one can effectively replace the entire stack with that address. The program to be executed (\"final payload\") is appended, ensuring that its position in the binary matches the entry-point from the previous step. The payload is padded to be evenly divisible by the 0x1000 block size to ensure the active block is not overwritten by the \"DMA dual-use\" bug described above. The exploit payload is sent to the device over EP1 OUT, tracking the number of 0x1000-byte \"blocks\" that have been sent to the device. If this number is even , the next write will be issued to the lower DMA buffer ( 0x40005000 ); otherwise, it will be issued to the upper DMA buffer ( 0x40009000 ). If the next write would target the lower DMA buffer, issue another write of a full 0x1000 bytes to move the target to the upper DMA buffer, reducing the total amount of data to be copied. Trigger the vulnerable memcpy by sending a GET_STATUS IN control request with an ENDPOINT recipient, and a length long enough to smash the desired stack region, and preferably not longer than required. A simple host program that triggers this vulnerability is included with this report: see fusee-launcher.py . Note the restrictions on its function in the following section.","title":"Exploit Execution"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/#proof-of-concept","text":"Included with this report is a set of three files: fusee-launcher.py -- The main proof-of-concept accompanying this report. This python script is designed to launch a simple binary payload in the described bootROM context via the exploit. intermezzo.bin -- This small stub is designed to relocate a payload from a higher load address to the standard RCM load address of 0x40010000 . This allows standard RCM payloads (such as nvtboot-recover.bin ) to be executed. fusee.bin -- An example payload for the Nintendo Switch, a representative and well-secured device based on a T210. This payload will print information from the device's fuses and protected IROM to the display, demonstrating that early bootROM execution has been achieved. Support note: Many host-OS driver stacks are reluctant to issue unreasonably large control requests. Accordingly, the current proof-of-concept includes code designed to work in the following environments: 64-bit linux via xhci_hcd . The proof-of-concept can manually submit large control requests, but does not work with the common ehci_hcd drivers due to driver limitations. A rough rule of thumb is that a connection via a blue / USB3 SuperSpeed port will almost always be handled by xhci_hcd . macOS . The exploit works out of the box with no surprises or restrictions on modern macOS. Windows support would require addition of a custom kernel module, and thus was beyond the scope of a simple proof-of-concept. To use this proof-of-concept on a Nintendo Switch: Set up an Linux or macOS environment that meets the criteria above, and which has a working python3 and pyusb as well as libusb installed. Connect the Switch to your host PC with a USB A -> USB C cable. Boot the Switch in RCM mode. There are three ways to do this, but the first-- unseating its eMMC board-- is likely the most straightforward: Ensure the Switch cannot boot off its eMMC. The most straightforward way to to this is to open the back cover and remove the socketed eMMC board; corrupting the BCT or bootloader on the eMMC boot partition would also work. Trigger the RCM straps. Hold VOL_UP and short pin 10 on the right JoyCon connector to ground while engaging the power button. Set bit 2 of PMC scratch register zero. On modern firmwares, this requires EL3 or pre-sleep BPMP execution. Run the fusee-launcher.py with an argument of fusee.bin . (This requires intermezzo.bin to be located in the same folder as fusee-launcher.py .) sudo python3 ./fusee-launcher.py fusee.bin If everything functions correctly, your Switch should be displaying a collection of fuse and protected-IROM information:","title":"Proof of Concept"},{"location":"Zune%20devices/Zune%20HD/Fusee%20Gelee/#recommended-mitigations","text":"In this case, the recommended mitigation is to correct the USB control request handler such that it always correctly constrains the length to be transmitted. This has to be handled according to the type of device: For a device already in consumer hands , no solution is proposed. Unfortunately, access to the fuses needed to configure the device's ipatches was blocked when the ODM_PRODUCTION fuse was burned, so no bootROM update is possible. It is suggested that consumers be made aware of the situation so they can move to other devices, where possible. For new devices , the correct solution is likely to introduce an new ipatch or new ipatches that limits the size of control request responses. It seems likely that OEMs producing T210-based devices may move to T214 solutions; it is the hope of the author that the T214's bootROM shares immunity with the T186. If not, patching the above is a recommended modification to the mask ROM and/or ipatches of the T214, as well.","title":"Recommended Mitigations"},{"location":"Zune%20devices/Zune%20HD/OpenGL%20ES/","text":"OpenGL ES The Zune HD supports the OpenGL ES 2.0 standard, which is basically OpenGL 2.0 but with a programmable render pipeline. Getting Started All you have to do in order to initialize OpenGL in your application is to include zdkgl.h and call ZDKGL_Initialize() on startup. Make sure to call ZDKGL_Cleanup() before exiting. Surround your render code with ZDKGL_BeginDraw() and ZDKGL_EndDraw() and you are good to go. Extensions The Zune HD also supports the following extensions. GL_OES_rgb8_rgba8 , GL_OES_fbo_render_mipmap , GL_NV_depth_nonlinear , GL_NV_draw_path , GL_OES_EGL_image , GL_OES_vertex_half_float , GL_NV_framebuffer_vertex_attrib_array , GL_NV_coverage_sample , GL_OES_mapbuffer , GL_ARB_draw_buffers , GL_ARB_half_float_pixel , GL_EXT_Cg_shader , GL_EXT_packed_float , GL_OES_texture_half_float , GL_OES_texture_float , GL_EXT_texture_array , GL_OES_compressed_ETC1_RGB8_texture , GL_EXT_texture_compression_latc , GL_EXT_texture_compression_s3tc , GL_EXT_texture_filter_anisotropic GL_NV_get_tex_image , GL_NV_read_buffer , GL_NV_shader_framebuffer_fetch , GL_ARB_texture_rectangle , GL_NV_fbo_color_attachments , GL_EXT_bgra maybe supported, have to check: GL_AMD_performance_monitor, GL_EXT_multi_draw_arrays","title":"OpenGL ES"},{"location":"Zune%20devices/Zune%20HD/OpenGL%20ES/#opengl-es","text":"The Zune HD supports the OpenGL ES 2.0 standard, which is basically OpenGL 2.0 but with a programmable render pipeline.","title":"OpenGL ES"},{"location":"Zune%20devices/Zune%20HD/OpenGL%20ES/#getting-started","text":"All you have to do in order to initialize OpenGL in your application is to include zdkgl.h and call ZDKGL_Initialize() on startup. Make sure to call ZDKGL_Cleanup() before exiting. Surround your render code with ZDKGL_BeginDraw() and ZDKGL_EndDraw() and you are good to go.","title":"Getting Started"},{"location":"Zune%20devices/Zune%20HD/OpenGL%20ES/#extensions","text":"The Zune HD also supports the following extensions. GL_OES_rgb8_rgba8 , GL_OES_fbo_render_mipmap , GL_NV_depth_nonlinear , GL_NV_draw_path , GL_OES_EGL_image , GL_OES_vertex_half_float , GL_NV_framebuffer_vertex_attrib_array , GL_NV_coverage_sample , GL_OES_mapbuffer , GL_ARB_draw_buffers , GL_ARB_half_float_pixel , GL_EXT_Cg_shader , GL_EXT_packed_float , GL_OES_texture_half_float , GL_OES_texture_float , GL_EXT_texture_array , GL_OES_compressed_ETC1_RGB8_texture , GL_EXT_texture_compression_latc , GL_EXT_texture_compression_s3tc , GL_EXT_texture_filter_anisotropic GL_NV_get_tex_image , GL_NV_read_buffer , GL_NV_shader_framebuffer_fetch , GL_ARB_texture_rectangle , GL_NV_fbo_color_attachments , GL_EXT_bgra maybe supported, have to check: GL_AMD_performance_monitor, GL_EXT_multi_draw_arrays","title":"Extensions"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/","text":"Partitions and Filesystems As the Zune is built on top of the NVIDIA Tegra APX 2600 platform it might use something similar to the default partition layout. Partition Layout from the Registry HKEY_LOCAL_MACHINE\\System\\StorageManager\\PartitionTable shows the partition layout of the Zune. \"01\"=\"FATFS\" \"04\"=\"FATFS\" \"06\"=\"FATFS\" \"07\"=\"MSIFS\" \"0B\"=\"FATFS\" \"0C\"=\"FATFS\" \"0E\"=\"FATFS\" \"0F\"=\"FATFS\" \"20\"=\"BOOT\" \"21\"=\"ZBINFS\" \"22\"=\"RAWFS\" \"23\"=\"RAWFS\" \"25\"=\"IMGFS\" \"26\"=\"BINARY\" Default Partition Layout from NVIDIA C:\\Program Files (x86)\\NVIDIA Corporation\\ce6_tegra_250_5265393\\os\\wince600_nand.cfg [device] type = nand instance = 0 [partition] name = BCT id = 2 type = boot_config_table allocation_policy = sequential filesystem_type = basic size = 3145728 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 0 [partition] name = PT id = 3 type = partition_table allocation_policy = sequential filesystem_type = basic size = 4096 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 0 [partition] name = EBT id = 4 type = bootloader allocation_policy = sequential filesystem_type = basic size = 4194304 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 0 filename = EBOOT.NB0 [partition] name = BMP id = 5 type = data allocation_policy = sequential filesystem_type = basic size = 5260 file_system_attribute = 0 filename = nvlogo_64x39_rgb565_wheader.raw allocation_attribute = 8 percent_reserved = 0 [partition] name = CE6 id = 7 type = data allocation_policy = sequential filesystem_type = basic size = 157286400 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 3 filename = NK.NB0 [partition] name = ARG id = 8 type = data allocation_policy = sequential filesystem_type = basic size = 2048 file_system_attribute = 0 allocation_attribute = 8 percent_reserved = 5 start_location = 0 [partition] name = DRM id = 9 type = data allocation_policy = sequential filesystem_type = basic size = 102400 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 300 filename = nvstorage.dat # update information partition [partition] name = UIP id = 11 type = data allocation_policy = sequential filesystem_type = basic size = 2048 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 10 # update staging partition [partition] name = USP id = 12 type = data allocation_policy = sequential filesystem_type = basic size = 167673856 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 5 [partition] name = USR id = 13 type = data allocation_policy = sequential filesystem_type = basic size = 0xFFFFFFFFFFFFFFFF file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 0 percent_reserved = 5 Filesystems ZCSTFS Zune Content File System DLL: zcstfs.dll This is the Filesystem for the XNA Storage containers stored as ZCP Files . ZBINFS Zune Binary File System DLL: zbinfs.dll FATFS FAT File System DLL: zexfat.dll EXFAT DLL: zexfat.dll exFAT File System MSIFS MSIFS uses the EXFAT format. ObjectStore DLL: filesys.dll \ud83d\uddfa\ufe0f Windows CE 6.0","title":"Partitions and Filesystems"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#partitions-and-filesystems","text":"As the Zune is built on top of the NVIDIA Tegra APX 2600 platform it might use something similar to the default partition layout.","title":"Partitions and Filesystems"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#partition-layout-from-the-registry","text":"HKEY_LOCAL_MACHINE\\System\\StorageManager\\PartitionTable shows the partition layout of the Zune. \"01\"=\"FATFS\" \"04\"=\"FATFS\" \"06\"=\"FATFS\" \"07\"=\"MSIFS\" \"0B\"=\"FATFS\" \"0C\"=\"FATFS\" \"0E\"=\"FATFS\" \"0F\"=\"FATFS\" \"20\"=\"BOOT\" \"21\"=\"ZBINFS\" \"22\"=\"RAWFS\" \"23\"=\"RAWFS\" \"25\"=\"IMGFS\" \"26\"=\"BINARY\"","title":"Partition Layout from the Registry"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#default-partition-layout-from-nvidia","text":"C:\\Program Files (x86)\\NVIDIA Corporation\\ce6_tegra_250_5265393\\os\\wince600_nand.cfg [device] type = nand instance = 0 [partition] name = BCT id = 2 type = boot_config_table allocation_policy = sequential filesystem_type = basic size = 3145728 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 0 [partition] name = PT id = 3 type = partition_table allocation_policy = sequential filesystem_type = basic size = 4096 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 0 [partition] name = EBT id = 4 type = bootloader allocation_policy = sequential filesystem_type = basic size = 4194304 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 0 filename = EBOOT.NB0 [partition] name = BMP id = 5 type = data allocation_policy = sequential filesystem_type = basic size = 5260 file_system_attribute = 0 filename = nvlogo_64x39_rgb565_wheader.raw allocation_attribute = 8 percent_reserved = 0 [partition] name = CE6 id = 7 type = data allocation_policy = sequential filesystem_type = basic size = 157286400 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 3 filename = NK.NB0 [partition] name = ARG id = 8 type = data allocation_policy = sequential filesystem_type = basic size = 2048 file_system_attribute = 0 allocation_attribute = 8 percent_reserved = 5 start_location = 0 [partition] name = DRM id = 9 type = data allocation_policy = sequential filesystem_type = basic size = 102400 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 300 filename = nvstorage.dat # update information partition [partition] name = UIP id = 11 type = data allocation_policy = sequential filesystem_type = basic size = 2048 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 10 # update staging partition [partition] name = USP id = 12 type = data allocation_policy = sequential filesystem_type = basic size = 167673856 file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 8 percent_reserved = 5 [partition] name = USR id = 13 type = data allocation_policy = sequential filesystem_type = basic size = 0xFFFFFFFFFFFFFFFF file_system_attribute = 0 partition_attribute = 0 allocation_attribute = 0 percent_reserved = 5","title":"Default Partition Layout from NVIDIA"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#filesystems","text":"","title":"Filesystems"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#zcstfs","text":"Zune Content File System DLL: zcstfs.dll This is the Filesystem for the XNA Storage containers stored as ZCP Files .","title":"ZCSTFS"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#zbinfs","text":"Zune Binary File System DLL: zbinfs.dll","title":"ZBINFS"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#fatfs","text":"FAT File System DLL: zexfat.dll","title":"FATFS"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#exfat","text":"DLL: zexfat.dll exFAT File System","title":"EXFAT"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#msifs","text":"MSIFS uses the EXFAT format.","title":"MSIFS"},{"location":"Zune%20devices/Zune%20HD/Partitions%20and%20Filesystems/#objectstore","text":"DLL: filesys.dll \ud83d\uddfa\ufe0f Windows CE 6.0","title":"ObjectStore"},{"location":"Zune%20devices/Zune%20HD/Windows%20CE%206.0/","text":"Windows CE 6.0 The Zune HD runs on Windows CE 6.0. Topics CE 6.0 Official Documentation CE 6.0 Architecture Device Manager Partitions and Filesystems","title":"Windows CE 6.0"},{"location":"Zune%20devices/Zune%20HD/Windows%20CE%206.0/#windows-ce-60","text":"The Zune HD runs on Windows CE 6.0.","title":"Windows CE 6.0"},{"location":"Zune%20devices/Zune%20HD/Windows%20CE%206.0/#topics","text":"CE 6.0 Official Documentation CE 6.0 Architecture Device Manager Partitions and Filesystems","title":"Topics"},{"location":"Zune%20software/","text":"Zune software The Zune software is a desktop application primarily made to sync media to and from Zune devices. Each of the four major releases roughly coincided with the release of a new generation of Zune: Version New Devices Release Date 1.0 Zune 30 November 2006 2.0 Zune 80, 4, 8 November 2007 3.0 Zune 120, 16 September 2008 4.0 Zune HD September 2009 4.7 Windows Phone 7 October 2010 Topics {{ pagetree(subtree) }}","title":"Zune software"},{"location":"Zune%20software/#zune-software","text":"The Zune software is a desktop application primarily made to sync media to and from Zune devices. Each of the four major releases roughly coincided with the release of a new generation of Zune: Version New Devices Release Date 1.0 Zune 30 November 2006 2.0 Zune 80, 4, 8 November 2007 3.0 Zune 120, 16 September 2008 4.0 Zune HD September 2009 4.7 Windows Phone 7 October 2010","title":"Zune software"},{"location":"Zune%20software/#topics","text":"{{ pagetree(subtree) }}","title":"Topics"},{"location":"Zune%20software/radio/","text":"Radio The Zune software contains unused functionality for managing and listening to internet radio stations. Demo Video View on Catbox. Accessing There are two methods of gaining access to the Radio view. Changing the Startup View The easiest way of accessing the Radio view is by changing the registry key used by the Startup View setting. If using the Registry Editor, navigate to HKCU/Software/Microsoft/Zune/Shell . Find the StartupView string value, and set it to Collection/Radio . When you launch the Zune software, the Radio screen of the Collection will be displayed. Enabling the Radio tab As discovered by Rafael Rivera, there is a hidden Radio tab in the Collection view that is normally permanently disabled. Enabling this tab requires dissassembling and modifying ZuneNativeLib.dll . Rafael's process on enabling the Radio tab can be found here. (alt) Stations Stations are stored as registry keys in HKCU/Software/Microsoft/Zune/Radio . Each station in your collection is stored as a sub-key within the Radio key. Within that key are two string values, SourceURL and Image. When the Zune software is installed, it automatically adds three stations to your collection; 107.7 The End, KEXP, and National Public Radio. Below is their values in the registry. This can be imported like a .reg file in order to restore these stations as well. Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio] [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio\\107.7 The End] \"SourceURL\"=\"http://38.116.147.101:80/KNDD?MSWMExt=.asf\" \"Image\"=\"res://ZuneShellResources!Radio.TheEnd.png\" @=\"\" [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio\\KEXP] \"SourceURL\"=\"http://kexp.org/audio/kexp-uncomp.asx\" \"Image\"=\"res://ZuneShellResources!Radio.KEXP.jpg\" @=\"\" [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio\\National Public Radio] \"SourceURL\"=\"http://128.208.34.65/multi\" \"Image\"=\"res://ZuneShellResources!Radio.NPR.jpg\" @=\"\" These stations are only added when the Zune software is installed, they do not restore themselves even if the Zune software is launched for the first time by another user account. All three stations reference thumbnail images that would have been stored in the Zune software itself. These images are not present, so they don't load and instead display the default cover art. Functionality In it's current state, Internet radio is non-functional, as the Zune software cannot play internet radio streams. Trying to play a station will act as if the Zune software failed to play a file. The view for managing radio stations is simplistic, and missing a lot of features in other Collection views. Adding a station is done by inputing the URL into a basic text field, and clicking the Add Station button. This is in contrast to the Podcasts collection view for example, where adding a podcast by URL is done in a pop-up dialog. Furthermore, there are no checks to make sure that an inputted URL is valid; clicking Add Station will immediately add a station with the contents of the URL box as the source URL, even if it isn't valid. There is a context menu available when multiple stations are selected, however the only option is to delete the selected stations. Selecting Delete will immeditately delete the stations without any warning, unlike in other Collection views. When there are no stations in the Collection, there are no extra links for searching the Zune Marketplace or adding a station by URL. Since there is no way to add a station in this state, it must be added manually to the registry. Bugs Now Playing When switching to the Now Playing view and back to the Collection, all stations will disappear from the view. Attempting to select all stations by clicking the \"* STATIONS\" text while in this state will crash the Zune software. Unimplemented Sorting feature In other Collection views, you can click the \"by *\" text to change how the content is sorted. This text appears in the Radio view, but clicking it here does nothing. Other Crashes Right-clicking a single station will crash the Zune software. Playing a station with an invalid SourceURL will crash the Zune software.","title":"Radio"},{"location":"Zune%20software/radio/#radio","text":"The Zune software contains unused functionality for managing and listening to internet radio stations.","title":"Radio"},{"location":"Zune%20software/radio/#demo-video","text":"View on Catbox.","title":"Demo Video"},{"location":"Zune%20software/radio/#accessing","text":"There are two methods of gaining access to the Radio view.","title":"Accessing"},{"location":"Zune%20software/radio/#changing-the-startup-view","text":"The easiest way of accessing the Radio view is by changing the registry key used by the Startup View setting. If using the Registry Editor, navigate to HKCU/Software/Microsoft/Zune/Shell . Find the StartupView string value, and set it to Collection/Radio . When you launch the Zune software, the Radio screen of the Collection will be displayed.","title":"Changing the Startup View"},{"location":"Zune%20software/radio/#enabling-the-radio-tab","text":"As discovered by Rafael Rivera, there is a hidden Radio tab in the Collection view that is normally permanently disabled. Enabling this tab requires dissassembling and modifying ZuneNativeLib.dll . Rafael's process on enabling the Radio tab can be found here. (alt)","title":"Enabling the Radio tab"},{"location":"Zune%20software/radio/#stations","text":"Stations are stored as registry keys in HKCU/Software/Microsoft/Zune/Radio . Each station in your collection is stored as a sub-key within the Radio key. Within that key are two string values, SourceURL and Image. When the Zune software is installed, it automatically adds three stations to your collection; 107.7 The End, KEXP, and National Public Radio. Below is their values in the registry. This can be imported like a .reg file in order to restore these stations as well. Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio] [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio\\107.7 The End] \"SourceURL\"=\"http://38.116.147.101:80/KNDD?MSWMExt=.asf\" \"Image\"=\"res://ZuneShellResources!Radio.TheEnd.png\" @=\"\" [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio\\KEXP] \"SourceURL\"=\"http://kexp.org/audio/kexp-uncomp.asx\" \"Image\"=\"res://ZuneShellResources!Radio.KEXP.jpg\" @=\"\" [HKEY_CURRENT_USER\\Software\\Microsoft\\Zune\\Radio\\National Public Radio] \"SourceURL\"=\"http://128.208.34.65/multi\" \"Image\"=\"res://ZuneShellResources!Radio.NPR.jpg\" @=\"\" These stations are only added when the Zune software is installed, they do not restore themselves even if the Zune software is launched for the first time by another user account. All three stations reference thumbnail images that would have been stored in the Zune software itself. These images are not present, so they don't load and instead display the default cover art.","title":"Stations"},{"location":"Zune%20software/radio/#functionality","text":"In it's current state, Internet radio is non-functional, as the Zune software cannot play internet radio streams. Trying to play a station will act as if the Zune software failed to play a file. The view for managing radio stations is simplistic, and missing a lot of features in other Collection views. Adding a station is done by inputing the URL into a basic text field, and clicking the Add Station button. This is in contrast to the Podcasts collection view for example, where adding a podcast by URL is done in a pop-up dialog. Furthermore, there are no checks to make sure that an inputted URL is valid; clicking Add Station will immediately add a station with the contents of the URL box as the source URL, even if it isn't valid. There is a context menu available when multiple stations are selected, however the only option is to delete the selected stations. Selecting Delete will immeditately delete the stations without any warning, unlike in other Collection views. When there are no stations in the Collection, there are no extra links for searching the Zune Marketplace or adding a station by URL. Since there is no way to add a station in this state, it must be added manually to the registry.","title":"Functionality"},{"location":"Zune%20software/radio/#bugs","text":"","title":"Bugs"},{"location":"Zune%20software/radio/#now-playing","text":"When switching to the Now Playing view and back to the Collection, all stations will disappear from the view. Attempting to select all stations by clicking the \"* STATIONS\" text while in this state will crash the Zune software.","title":"Now Playing"},{"location":"Zune%20software/radio/#unimplemented-sorting-feature","text":"In other Collection views, you can click the \"by *\" text to change how the content is sorted. This text appears in the Radio view, but clicking it here does nothing.","title":"Unimplemented Sorting feature"},{"location":"Zune%20software/radio/#other-crashes","text":"Right-clicking a single station will crash the Zune software. Playing a station with an invalid SourceURL will crash the Zune software.","title":"Other Crashes"},{"location":"Zune%20software/Iris/","text":"Microsoft Iris Topics {{ pagetree(subtree) }} What is Microsoft Iris? Microsoft Iris (sometimes called UIX) is a private UI framework for Windows. It was developed for internal use by various Microsoft Windows software, although only the Zune desktop software is known to use it. Unlike most modern UI frameworks, Iris does not provide default control styles-- library consumers are expected to define their own styles. However, some later versions of Iris included UIXControls.dll , a resource library containing some limited styles for built-in controls. UI layouts are defined in XML-based .uix files, which are nearly identical in structure to Media Center Markup Language (MCML) . Starting with Iris 3, a compiler was included that processed the XML-based layouts into a proprietary binary format. Parts of the code suggest that Iris may have supported the Xbox 360 (referred to by its codename, Xenon). There is also evidence that a native version of the library was used by some in-box applications in Windows Phone 7, where it was referred to as \"Splash\". What does Microsoft Iris have to do with Zune? Zune software 2.0 introduced a new UI design, which later become the Metro design language. This was also the first version to utilize the then-new Iris framework. Iris's assembly version generally aligns with the Zune release it came with-- the first known release of Iris is 2.0 for this reason. Iris 2 also did not have the concept of \"compiled UIX\", so Zune 2.x releases contain readable UIX source code. The Zune desktop software is partially written in C#, namely ZuneShell.dll . This library contains the entrypoint that Zune.exe passes execution to. Along with the Iris startup code, it primarily contains code that glues some parts of the UI and the business logic together. However, note that the majority of the UI logic was written as embedded UIX scripts in the various resource DLLs. In Zune desktop 4.x, the scripts are compiled to custom bytecode. How can I use Microsoft Iris? Despite being very powerful and flexible compared to other UI frameworks of the time, Microsoft never released Iris for public use. Microsoft.Iris.Application.VerifyTrustedEnvironment() is called on startup in Iris applications to verify that the calling assembly is signed by Microsoft. This check can be patched out with relative ease, though it should be done with caution. Distributing patched binaries violates U.S. copyright law and may land you in hot water. History 2.x Microsoft Iris first appeared in the release of version 2.0 of the Zune desktop software. No pre-built controls were included at all, with even primitives like buttons requiring consumer to build from scratch. Compiled UIX also did not exist at this time. Instead, Iris would parse and interpret UIX XML at runtime. UIX XML syntax closely resembled US-20090327876-A1 , a patent filed by Microsoft at the end of 2009, and Media Center Markup Language (MCML) as used by Windows Media Center . 3.x Iris 3.0 released with Zune 3.0 in late 2008. It was the most significant update to Iris as it introduced the UIX compiler; rather than parsing XML at runtime, Iris could compile UIX files at buildtime into UIB 3 a proprietary format that resembled custom bytecode. The shipped version of UIX.dll includes the original UIX XML interpreter and the binary UIX compiler for UIB 3, although neither are used by the Zune software at runtime. The UIX XML syntax was changed sightly from the source included in Zune 2.0. For example: Assignments and expressions in bracketless conditionals are no longer wrapped in square brackets. HyperlinkRepeater.Source = [Text.Fragments]; to HyperlinkRepeater.Source = Text.Fragments; if ([FragmentMouseFocus.Value]) to if (FragmentMouseFocus.Value) Canonical instances are accessed as if they are static members using dot syntax. <toptoolbar:TopToolbar Name= \"TopToolbar\" Shell= \"{Shell}\" FocusOrder= \"1\" > <LayoutInput> <DockLayoutInput Position= \"Top\" /> </LayoutInput> </toptoolbar:TopToolbar> becomes <toptoolbar:TopToolbar Name= \"TopToolbar\" Shell= \"{Shell}\" FocusOrder= \"1\" LayoutInput= \"{DockLayoutInput.Top}\" /> 4.x Iris 4.0 was a minor update released with Zune 4.0 in 2009, which utilized a new version of the compiler and UIB 4 to reduce the size and overhead of UIX. Iris 4 also included UIXcontrols.dll , a simple library containing some .NET code and implementations of basic controls such as buttons and scrollbars and some higher level but still primitive building blocks. Zune 4.8.2345.0 shipped the last known version of Iris, with the same assembly version as Zune.","title":"Microsoft Iris"},{"location":"Zune%20software/Iris/#microsoft-iris","text":"","title":"Microsoft Iris"},{"location":"Zune%20software/Iris/#topics","text":"{{ pagetree(subtree) }}","title":"Topics"},{"location":"Zune%20software/Iris/#what-is-microsoft-iris","text":"Microsoft Iris (sometimes called UIX) is a private UI framework for Windows. It was developed for internal use by various Microsoft Windows software, although only the Zune desktop software is known to use it. Unlike most modern UI frameworks, Iris does not provide default control styles-- library consumers are expected to define their own styles. However, some later versions of Iris included UIXControls.dll , a resource library containing some limited styles for built-in controls. UI layouts are defined in XML-based .uix files, which are nearly identical in structure to Media Center Markup Language (MCML) . Starting with Iris 3, a compiler was included that processed the XML-based layouts into a proprietary binary format. Parts of the code suggest that Iris may have supported the Xbox 360 (referred to by its codename, Xenon). There is also evidence that a native version of the library was used by some in-box applications in Windows Phone 7, where it was referred to as \"Splash\".","title":"What is Microsoft Iris?"},{"location":"Zune%20software/Iris/#what-does-microsoft-iris-have-to-do-with-zune","text":"Zune software 2.0 introduced a new UI design, which later become the Metro design language. This was also the first version to utilize the then-new Iris framework. Iris's assembly version generally aligns with the Zune release it came with-- the first known release of Iris is 2.0 for this reason. Iris 2 also did not have the concept of \"compiled UIX\", so Zune 2.x releases contain readable UIX source code. The Zune desktop software is partially written in C#, namely ZuneShell.dll . This library contains the entrypoint that Zune.exe passes execution to. Along with the Iris startup code, it primarily contains code that glues some parts of the UI and the business logic together. However, note that the majority of the UI logic was written as embedded UIX scripts in the various resource DLLs. In Zune desktop 4.x, the scripts are compiled to custom bytecode.","title":"What does Microsoft Iris have to do with Zune?"},{"location":"Zune%20software/Iris/#how-can-i-use-microsoft-iris","text":"Despite being very powerful and flexible compared to other UI frameworks of the time, Microsoft never released Iris for public use. Microsoft.Iris.Application.VerifyTrustedEnvironment() is called on startup in Iris applications to verify that the calling assembly is signed by Microsoft. This check can be patched out with relative ease, though it should be done with caution. Distributing patched binaries violates U.S. copyright law and may land you in hot water.","title":"How can I use Microsoft Iris?"},{"location":"Zune%20software/Iris/#history","text":"","title":"History"},{"location":"Zune%20software/Iris/#2x","text":"Microsoft Iris first appeared in the release of version 2.0 of the Zune desktop software. No pre-built controls were included at all, with even primitives like buttons requiring consumer to build from scratch. Compiled UIX also did not exist at this time. Instead, Iris would parse and interpret UIX XML at runtime. UIX XML syntax closely resembled US-20090327876-A1 , a patent filed by Microsoft at the end of 2009, and Media Center Markup Language (MCML) as used by Windows Media Center .","title":"2.x"},{"location":"Zune%20software/Iris/#3x","text":"Iris 3.0 released with Zune 3.0 in late 2008. It was the most significant update to Iris as it introduced the UIX compiler; rather than parsing XML at runtime, Iris could compile UIX files at buildtime into UIB 3 a proprietary format that resembled custom bytecode. The shipped version of UIX.dll includes the original UIX XML interpreter and the binary UIX compiler for UIB 3, although neither are used by the Zune software at runtime. The UIX XML syntax was changed sightly from the source included in Zune 2.0. For example: Assignments and expressions in bracketless conditionals are no longer wrapped in square brackets. HyperlinkRepeater.Source = [Text.Fragments]; to HyperlinkRepeater.Source = Text.Fragments; if ([FragmentMouseFocus.Value]) to if (FragmentMouseFocus.Value) Canonical instances are accessed as if they are static members using dot syntax. <toptoolbar:TopToolbar Name= \"TopToolbar\" Shell= \"{Shell}\" FocusOrder= \"1\" > <LayoutInput> <DockLayoutInput Position= \"Top\" /> </LayoutInput> </toptoolbar:TopToolbar> becomes <toptoolbar:TopToolbar Name= \"TopToolbar\" Shell= \"{Shell}\" FocusOrder= \"1\" LayoutInput= \"{DockLayoutInput.Top}\" />","title":"3.x"},{"location":"Zune%20software/Iris/#4x","text":"Iris 4.0 was a minor update released with Zune 4.0 in 2009, which utilized a new version of the compiler and UIB 4 to reduce the size and overhead of UIX. Iris 4 also included UIXcontrols.dll , a simple library containing some .NET code and implementations of basic controls such as buttons and scrollbars and some higher level but still primitive building blocks. Zune 4.8.2345.0 shipped the last known version of Iris, with the same assembly version as Zune.","title":"4.x"},{"location":"Zune%20software/Iris/compiled-uix/","text":"Compiled UIX v4 Compiled UIX (often shortened to \"UIB\" for \"UI Binary\") is one of two formats used by Iris 4 for defining user interfaces. UIB is generated by passing one or more UIX XML files to the UIX compiler, which pre-processes the UI definition into custom bytecode alongside a slew of data tables. Although UIB bytecode instructions are much higher level, the interpreter is conceptually similar to emulating a CPU in that they are relatively simple instructions which are interpreted in a fetch + decode + execute loop. Note that the format used by Iris 4 is significantly different than Iris 3's UIB , which can be identified with the file magic \"UIX2008\" . Nearly all of the markup-related code is in the Microsoft.Iris.Markup namespace, including compiled UIX. Most of the functions responsible for loading compiled UIX files is in Microsoft.Iris.Markup.CompiledMarkupLoader , with some key functionality being delegated to other classes. Most notably, the bytecode interpreter is implemented in Microsoft.Iris.Markup.Interpreter . Data format Being a binary data format, UIB is capable of storing several primitive data types. All integers are stored in little endian, as is standard for Windows. Offsets All offsets are stored as unsigned 32-bit integers ( UInt32 ), relative to the start of the file unless otherwise specified. Offset ranges are typically specified with an inclusive start offset and exclusive end offset: \\([\\mathrm{Start}, \\mathrm{End})\\) . Strings Strings are stored length-prefixed with a UInt16 preamble, followed by encoded characters. If the preamble is 0xFFFF , the string is null. Otherwise, the most significant bit indicates whether the characters are UTF-8 encoded, and the remaining 15 bits are the number of characters (not bytes) in the string. Length value (binary) Meaning 1111 1111 1111 1111 Null string 1xxx xxxx xxxx xxxx UTF-8 character encoding 0xxx xxxx xxxx xxxx UTF-16 character encoding String references Most strings are not stored inline, but instead as Int32 indexes into the Strings section of the Binary Data Table . This allows for common strings to be deduplicated, which can reduce file size. String arrays String arrays are lists of string references . This means that they are effectively Int32 arrays, where each item is an index into the Strings list in the Binary Data Table . Integer arrays Arrays of 32-bit integers are also stored prefixed with their length, where, similarly to strings, a 'negative length' is interpreted as a null array. Otherwise, each integer is stored one after the other. Both signed and unsigned integers ( UInt32 and Int32 ) can be stored with in this format, but the Iris library always reads the values as unsigned, requiring callers to cast the value to Int32 for signed integers. Booleans Boolean values are stored as a single byte, where 0 represents false and 1 represents true . Enums Enums are usually stored as 32-bit integers. Naturally, the meaning of a particular integer value depends which enum it is intended to be. MarkupType Name Value None 0x00000000 UI 0x01000000 Class 0x02000000 Effect 0x03000000 DataType 0x04000000 DataQuery 0x05000000 File structure A custom binary format is used to store all compiler output. This format is divided into several sections, and can even be split across multiple files using shared Data Tables . Header The first four bytes are always 0x5549421A , which spell out \"UIB\u241a\" in ASCII. The next four bytes contain some representation of the UIB version, although the exact format is unknown. All known Iris 4 releases, including 4.0 and 4.8 Beta, use 1012 ( 0x3F4 ). Table of Contents The Table of Contents begins at offset 0x0008 , with two offsets specifying the start and end of the Object Section . Locations 0x0010 and 0x0014 contain the start and end of the Line Number Table , respectively. The last item stored in the Table of Contents is a reference to the Binary Data Table . This is composed of two fields, of which only one can be set at at time. The value at offset 0x0018 is the start of a string . If the string is not null, then it is used as the resource URI to load a shared Data Table from. If it is null, then the UInt32 at location 0x001A is the offset to the Data Table embedded within the current file. Dependencies The Dependencies section is a list of UIX files to include, encoded as the unsigned 16-bit count followed by a series of entries. Each include is composed of a flag that stores whether the referenced file is UIX XML, and the reference's compiler name string . This name is almost always the URI the file was loaded from. As an example, a Dependencies section with two includes might be stored as shown below. Note that all offsets are relative to the first byte of the dependency count. Start offset Value Meaning 0x00 0x02000000 The list contains 2 includes 0x04 0x00000000 dependencies[0] is compiled UIB 0x05 0x05000000 The URI of the 1st dependency is the 6th string in the Data Table 0x09 0x01 dependencies[1] is UIX XML 0x10 0x02000000 The URI of the 2nd dependency is the 3rd string in the Data Table Type Export Declarations The Type Export Declarations are composed of two tables: the Export Table and Alias Table. The Export Table is a length-prefixed ( UInt16 ) list of exports, where each export is a type defined with a reference to the local name and the markup type . The Alias Table allows a UIB file to export imported types under a different name. Each entry is exactly 10 ( 0x0A ) bytes long and is composed of the desired alias, the dependency to load it from, and the name of the target type. Both the alias and target type name are stored a string references . The dependency is always referred to using an index, either into the Type Import Table of the Shared Binary Data Table if one is specified, or the file's dependencies . Offset into entry Meaning 0x00 String reference to the desired Alias 0x04 UInt16 index into the Dependencies list 0x06 String reference to the target type name Binary Data Table The Binary Data Table consists of several subtables, with each one containing a different types of constant data. These subtables are stored in the following order: 1. Strings 1. ??? Strings table The Strings table is effectively a list of strings, though unlike the primitive string[] , it is actually stored as char[][] . The first four bytes of the Strings table contain the length of the list as a 32-bit integer. Although this value cannot be negative, UIX.dll ultimately uses this as an Int32 to allocate memory, so theoretically a maximum of 0x7FFFFFFF or 2,147,483,647 strings can be stored in a single UIB file. Following the string count is a series of offsets relative to the first entry in the offset table (the byte immediately after the string count bytes). This is used similarly to a jump table, where the first chunk of the table is an array of fixed-size offsets into the second chunk. When UIB file is being read from fixed memory, this allows Iris to jump directly to the requested string using its index without having to read the entire table or every string before it. As an example, a string table with three entries might be stored as shown below. Note that all offsets are relative to first entry in the jump table. Start offset Value Meaning -0x04 0x03000000 The table contains 3 strings 0x00 0x0C000000 strings[0] is located at offset 0x0C 0x04 0x1D000000 strings[1] is located at offset 0x1D 0x08 0x23000000 strings[2] is located at offset 0x23 0x0C 0x08000000 strings[0] is 8 UTF-16 characters 0x0D \"\u0393\u03b5\u03b9\u03b1 \u03c3\u03b1\u03c2\" strings[0] character data 0x1D 0x05800000 strings[1] is 5 UTF-8 characters 0x1E \"Howdy\" strings[1] character data 0x23 0x08800000 strings[2] is 8 UTF-8 characters 0x24 \"MOREtext\" strings[2] character data Constants Table Type Import Table Source Markup Import Tables Line Number Table Object Section Export Table Load passes [Work in progress] Compiled UIX is loaded in three main passes, listed in order of execution below. \"Depersist\" usually refers to reading and processing encoded information, such as type exports. Declare types Depersist Table of Contents Depersist Binary Data Table Depersist Dependencies Depersist Type Export Declarations Populate public model Depersist Type Import Table Depersist Type Export Definition Full Depersist Data Mappings Table Depersist Constants Table Depersist Line Number Table Depersist Object Section TODO Iris has two separate type systems-- the runtime types, which are your standard .NET types; and the markup type schemas, which of course are .NET types themselves, but are used to wrap runtime types for use by the UIX compiler and interpreter. Mapping from schema to runtime type and constructing instances from strings is easy enough, because those are both tasks the original UIX tooling has to do. Doing the reverse (finding the schema for a given runtime type, or encoding a runtime object into a string that can be parsed later) is much more difficult.","title":"Compiled UIX v4"},{"location":"Zune%20software/Iris/compiled-uix/#compiled-uix-v4","text":"Compiled UIX (often shortened to \"UIB\" for \"UI Binary\") is one of two formats used by Iris 4 for defining user interfaces. UIB is generated by passing one or more UIX XML files to the UIX compiler, which pre-processes the UI definition into custom bytecode alongside a slew of data tables. Although UIB bytecode instructions are much higher level, the interpreter is conceptually similar to emulating a CPU in that they are relatively simple instructions which are interpreted in a fetch + decode + execute loop. Note that the format used by Iris 4 is significantly different than Iris 3's UIB , which can be identified with the file magic \"UIX2008\" . Nearly all of the markup-related code is in the Microsoft.Iris.Markup namespace, including compiled UIX. Most of the functions responsible for loading compiled UIX files is in Microsoft.Iris.Markup.CompiledMarkupLoader , with some key functionality being delegated to other classes. Most notably, the bytecode interpreter is implemented in Microsoft.Iris.Markup.Interpreter .","title":"Compiled UIX v4"},{"location":"Zune%20software/Iris/compiled-uix/#data-format","text":"Being a binary data format, UIB is capable of storing several primitive data types. All integers are stored in little endian, as is standard for Windows.","title":"Data format"},{"location":"Zune%20software/Iris/compiled-uix/#offsets","text":"All offsets are stored as unsigned 32-bit integers ( UInt32 ), relative to the start of the file unless otherwise specified. Offset ranges are typically specified with an inclusive start offset and exclusive end offset: \\([\\mathrm{Start}, \\mathrm{End})\\) .","title":"Offsets"},{"location":"Zune%20software/Iris/compiled-uix/#strings","text":"Strings are stored length-prefixed with a UInt16 preamble, followed by encoded characters. If the preamble is 0xFFFF , the string is null. Otherwise, the most significant bit indicates whether the characters are UTF-8 encoded, and the remaining 15 bits are the number of characters (not bytes) in the string. Length value (binary) Meaning 1111 1111 1111 1111 Null string 1xxx xxxx xxxx xxxx UTF-8 character encoding 0xxx xxxx xxxx xxxx UTF-16 character encoding","title":"Strings"},{"location":"Zune%20software/Iris/compiled-uix/#string-references","text":"Most strings are not stored inline, but instead as Int32 indexes into the Strings section of the Binary Data Table . This allows for common strings to be deduplicated, which can reduce file size.","title":"String references"},{"location":"Zune%20software/Iris/compiled-uix/#string-arrays","text":"String arrays are lists of string references . This means that they are effectively Int32 arrays, where each item is an index into the Strings list in the Binary Data Table .","title":"String arrays"},{"location":"Zune%20software/Iris/compiled-uix/#integer-arrays","text":"Arrays of 32-bit integers are also stored prefixed with their length, where, similarly to strings, a 'negative length' is interpreted as a null array. Otherwise, each integer is stored one after the other. Both signed and unsigned integers ( UInt32 and Int32 ) can be stored with in this format, but the Iris library always reads the values as unsigned, requiring callers to cast the value to Int32 for signed integers.","title":"Integer arrays"},{"location":"Zune%20software/Iris/compiled-uix/#booleans","text":"Boolean values are stored as a single byte, where 0 represents false and 1 represents true .","title":"Booleans"},{"location":"Zune%20software/Iris/compiled-uix/#enums","text":"Enums are usually stored as 32-bit integers. Naturally, the meaning of a particular integer value depends which enum it is intended to be.","title":"Enums"},{"location":"Zune%20software/Iris/compiled-uix/#markuptype","text":"Name Value None 0x00000000 UI 0x01000000 Class 0x02000000 Effect 0x03000000 DataType 0x04000000 DataQuery 0x05000000","title":"MarkupType"},{"location":"Zune%20software/Iris/compiled-uix/#file-structure","text":"A custom binary format is used to store all compiler output. This format is divided into several sections, and can even be split across multiple files using shared Data Tables .","title":"File structure"},{"location":"Zune%20software/Iris/compiled-uix/#header","text":"The first four bytes are always 0x5549421A , which spell out \"UIB\u241a\" in ASCII. The next four bytes contain some representation of the UIB version, although the exact format is unknown. All known Iris 4 releases, including 4.0 and 4.8 Beta, use 1012 ( 0x3F4 ).","title":"Header"},{"location":"Zune%20software/Iris/compiled-uix/#table-of-contents","text":"The Table of Contents begins at offset 0x0008 , with two offsets specifying the start and end of the Object Section . Locations 0x0010 and 0x0014 contain the start and end of the Line Number Table , respectively. The last item stored in the Table of Contents is a reference to the Binary Data Table . This is composed of two fields, of which only one can be set at at time. The value at offset 0x0018 is the start of a string . If the string is not null, then it is used as the resource URI to load a shared Data Table from. If it is null, then the UInt32 at location 0x001A is the offset to the Data Table embedded within the current file.","title":"Table of Contents"},{"location":"Zune%20software/Iris/compiled-uix/#dependencies","text":"The Dependencies section is a list of UIX files to include, encoded as the unsigned 16-bit count followed by a series of entries. Each include is composed of a flag that stores whether the referenced file is UIX XML, and the reference's compiler name string . This name is almost always the URI the file was loaded from. As an example, a Dependencies section with two includes might be stored as shown below. Note that all offsets are relative to the first byte of the dependency count. Start offset Value Meaning 0x00 0x02000000 The list contains 2 includes 0x04 0x00000000 dependencies[0] is compiled UIB 0x05 0x05000000 The URI of the 1st dependency is the 6th string in the Data Table 0x09 0x01 dependencies[1] is UIX XML 0x10 0x02000000 The URI of the 2nd dependency is the 3rd string in the Data Table","title":"Dependencies"},{"location":"Zune%20software/Iris/compiled-uix/#type-export-declarations","text":"The Type Export Declarations are composed of two tables: the Export Table and Alias Table. The Export Table is a length-prefixed ( UInt16 ) list of exports, where each export is a type defined with a reference to the local name and the markup type . The Alias Table allows a UIB file to export imported types under a different name. Each entry is exactly 10 ( 0x0A ) bytes long and is composed of the desired alias, the dependency to load it from, and the name of the target type. Both the alias and target type name are stored a string references . The dependency is always referred to using an index, either into the Type Import Table of the Shared Binary Data Table if one is specified, or the file's dependencies . Offset into entry Meaning 0x00 String reference to the desired Alias 0x04 UInt16 index into the Dependencies list 0x06 String reference to the target type name","title":"Type Export Declarations"},{"location":"Zune%20software/Iris/compiled-uix/#binary-data-table","text":"The Binary Data Table consists of several subtables, with each one containing a different types of constant data. These subtables are stored in the following order: 1. Strings 1. ???","title":"Binary Data Table"},{"location":"Zune%20software/Iris/compiled-uix/#strings-table","text":"The Strings table is effectively a list of strings, though unlike the primitive string[] , it is actually stored as char[][] . The first four bytes of the Strings table contain the length of the list as a 32-bit integer. Although this value cannot be negative, UIX.dll ultimately uses this as an Int32 to allocate memory, so theoretically a maximum of 0x7FFFFFFF or 2,147,483,647 strings can be stored in a single UIB file. Following the string count is a series of offsets relative to the first entry in the offset table (the byte immediately after the string count bytes). This is used similarly to a jump table, where the first chunk of the table is an array of fixed-size offsets into the second chunk. When UIB file is being read from fixed memory, this allows Iris to jump directly to the requested string using its index without having to read the entire table or every string before it. As an example, a string table with three entries might be stored as shown below. Note that all offsets are relative to first entry in the jump table. Start offset Value Meaning -0x04 0x03000000 The table contains 3 strings 0x00 0x0C000000 strings[0] is located at offset 0x0C 0x04 0x1D000000 strings[1] is located at offset 0x1D 0x08 0x23000000 strings[2] is located at offset 0x23 0x0C 0x08000000 strings[0] is 8 UTF-16 characters 0x0D \"\u0393\u03b5\u03b9\u03b1 \u03c3\u03b1\u03c2\" strings[0] character data 0x1D 0x05800000 strings[1] is 5 UTF-8 characters 0x1E \"Howdy\" strings[1] character data 0x23 0x08800000 strings[2] is 8 UTF-8 characters 0x24 \"MOREtext\" strings[2] character data","title":"Strings table"},{"location":"Zune%20software/Iris/compiled-uix/#constants-table","text":"","title":"Constants Table"},{"location":"Zune%20software/Iris/compiled-uix/#type-import-table","text":"","title":"Type Import Table"},{"location":"Zune%20software/Iris/compiled-uix/#source-markup-import-tables","text":"","title":"Source Markup Import Tables"},{"location":"Zune%20software/Iris/compiled-uix/#line-number-table","text":"","title":"Line Number Table"},{"location":"Zune%20software/Iris/compiled-uix/#object-section","text":"","title":"Object Section"},{"location":"Zune%20software/Iris/compiled-uix/#export-table","text":"","title":"Export Table"},{"location":"Zune%20software/Iris/compiled-uix/#load-passes","text":"[Work in progress] Compiled UIX is loaded in three main passes, listed in order of execution below. \"Depersist\" usually refers to reading and processing encoded information, such as type exports. Declare types Depersist Table of Contents Depersist Binary Data Table Depersist Dependencies Depersist Type Export Declarations Populate public model Depersist Type Import Table Depersist Type Export Definition Full Depersist Data Mappings Table Depersist Constants Table Depersist Line Number Table Depersist Object Section","title":"Load passes"},{"location":"Zune%20software/Iris/compiled-uix/#todo","text":"Iris has two separate type systems-- the runtime types, which are your standard .NET types; and the markup type schemas, which of course are .NET types themselves, but are used to wrap runtime types for use by the UIX compiler and interpreter. Mapping from schema to runtime type and constructing instances from strings is easy enough, because those are both tasks the original UIX tooling has to do. Doing the reverse (finding the schema for a given runtime type, or encoding a runtime object into a string that can be parsed later) is much more difficult.","title":"TODO"},{"location":"Zune%20software/Iris/uix-assembly/","text":"UIX Assembly Instruction Set Summary General Mneumonic Name COBJ ConstructObject COBJI ConstructObjectIndirect COBP ConstructObjectParam CSTR ConstructFromString CBIN ConstructFromBinary INIT InitializeInstance INITI InitializeInstanceIndirect LSYM LookupSymbol WSYM WriteSymbol WSYMP WriteSymbolPeek CSYM ClearSymbol PINI PropertyInitialize PINII PropertyInitializeIndirect PLAD PropertyListAdd PDAD PropertyDictionaryAdd PASS PropertyAssign PASST PropertyAssignStatic PGET PropertyGet PGETP PropertyGetPeek PGETT PropertyGetStatic MINV MethodInvoke MINVP MethodInvokePeek MINVT MethodInvokeStatic MINVA MethodInvokePushLastParam MINVAT MethodInvokeStaticPushLastParam VTC VerifyTypeCast CON ConvertType OPR Operation ISC IsCheck ASC As TYP TypeOf PSHN PushNull PSHC PushConstant PSHT PushThis DIS DiscardValue RET ReturnValue RETV ReturnVoid JMPF JumpIfFalse JMPFP JumpIfFalsePeek JMPTP JumpIfTruePeek JMPD JumpIfDictionaryContains JMPNP JumpIfNullPeek JMP Jump CLIS ConstructListenerStorage LIS Listen LISD DestructiveListen DBG EnterDebugState Math Operators Mneumonic Name ADD MathAdd SUB MathSubtract MUL MathMultiply DIV MathDivide MOD MathModulus NEG MathNegate AND LogicalAnd ORR LogicalOr NOT LogicalNot REQ RelationalEquals RNE RelationalNotEquals RLT RelationalLessThan RGT RelationalGreaterThan RLE RelationalLessThanEquals RGE RelationalGreaterThanEquals RIS RelationalIs INC PostIncrement DEC PostDecrement Object instantiation This family of instructions calls the constructor for the given object. All variants take the index of the object type to construct. ConstructObject Calls the default constructor with no parameters. COBJ < typeIndex > ConstructObjectIndirect Used to create 'wrappers' of another constructed object. It is used for type schemas that implement IDynamicConstructionSchema , which appears to only be used by UIClassTypeSchema for creating the root <UI> element. The assignment type is taken from the first operand, while the target type is popped off the stack. COBJI < assignmentTypeIndex > ConstructObjectParam Calls the specified constructor with N parameters popped from the stack, with the N th parameter at the top of the stack. The number of parameters must match the constructor exactly. COBP < typeIndex > , < constructorIndex > ConstructFromString Uses the target's type converter to construct an instance from a constant string. CSTR < typeIndex > , < stringIndex > ConstructFromBinary Uses the target type's binary decoder to construct an instance from a binary blob. The blob is stored inline and can be any length. The binary decoder is responsible for determining the length and consuming the entire blob. InitializeInstance Pops an object from the stack and initializes it using the specified type schema. This instruction is required to initialize UIClass and Class objects immediately after construction. INIT < typeIndex > InitializeInstanceIndirect Identical to InitializeInstance , except the type schema is popped off the stack rather than indexed from the type imports table. INITI Symbols This family of instructions manages symbols, usually local variables. LookupSymbol Looks up a symbol in the symbol reference table and pushes its value to the stack. LSYM < symbolReferenceIndex > WriteSymbol Writes a value popped from the stack to the specified symbol in the symbol reference table. WSYM < symbolReferenceIndex > WriteSymbolPeek Identical to WriteSymbol , except the value to be written is peeked instead of popped off the stack. WSYMP < symbolReferenceIndex > ClearSymbol If the specified symbol is a scoped local, it is undeclared. Otherwise, this instruction is a no-op. CSYM < symbolReferenceIndex > Properties PropertyInitialize Pops a value from the stack and initializes the specified property on the current instance, also popped from the stack. PINI < propertyIndex > PropertyInitializeIndirect Simimlar to PropertyInitialize , except the parent type schema is popped from the stack. PINII < propertyIndex > PropertyListAdd Pops a value from the stack and appends it to the end of a list. The key is read from the constants table. The target object is peeked from the stack. If propertyIndex is 0xFFFF , the target object is the list itself. Otherwise, the list is read from the specified property on the target object. PLAD < propertyIndex > // target.Property.Add(value) PLAD 0xFFFF // target.Add(value) PropertyDictionaryAdd Pops a value from the stack and assigns it to the given key in a dictionary. The same semantics from PropertyListAdd regarding propretyIndex apply. PDAD < propertyIndex > , < keyConstantIndex > // target.Property[value] = value PDAD 0xFFFF , < keyConstantIndex > // target[key] = value PropertyAssign Assigns a value to the specified property. The target object is popped from the stack before the value is peeked. PASS < propertyIndex > ; object.Property = value PropertyAssignStatic Peeks a value from the stack and assigns it to the specified static property. PASST < propertyIndex > ; StaticInstance.Property = value PropertyGet Pops a parent object from the stack and pushes the value of the specified property. PGET < propertyIndex > ; object.Property PropertyGetPeek Peeks an object from the stack and pushes the value of the specified property. PGETP < propertyIndex > ; object.Property PropertyGetStatic Pushes the value of the specified static property to the stack. PGETT < propertyIndex > ; StaticInstance.Property Methods MethodInvoke Invokes the specified method with N parameters popped from the stack, with the N th parameter at the top of the stack. The number of parameters must match the method signature exactly. The parent object is popped from the stack. If the method has a return value, it is pushed to the stack. MINV < methodIndex > MethodInvokePeek Identical to MethodInvoke , except the parent object is peeked instead of popped from the stack. MINVP < methodIndex > MethodInvokeStatic Identical to MethodInvoke , except the method must be static and no parent object is popped from the stack. MINVT < methodIndex > MethodInvokePushLastParam Similar to MethodInvoke , except the last parameter is pushed to the stack. When this mode is used, the method return value is not pushed to the stack. MINVA < methodIndex > MethodInvokeStaticPushLastParam Similar to MethodInvokeStatic , except the last parameter is pushed to the stack. When this mode is used, the method return value is not pushed to the stack. Equivalent to MethodInvokePushLastParam but for static methods. MINVAT < methodIndex > Type Manipulation This family of instructions performs operations that manipulate types. VerifyTypeCast Throws a script runtime error if the object at the top of the stack cannot be cast to the specified type. VTC < propertyIndex > ConvertType Pops an object from the stack and converts from one specified type to another. The converted object is pushed to the stack. Note that this is not equivalent to a simple cast: see As . CON < toTypeIndex > , < fromTypeIndex > IsCheck Pops an object from the stack and checks whether it is an instance of the specified type. The check result is pushed as a bool to the stack. Returns false is the object is null . ISC < typeIndex > As If the object at the top of the stack is assignable to the specified type, no action is taken. Otherwise, the object is replaced with null . ASC < typeIndex > TypeOf Pushes the schema of the specified type to the stack. TYP < typeIndex > Arithmetic and Logical Operations Operation Performs the specified arithmetic or logical operation using the provided operation host type schema. Unary operations will pop a single value off the stack and execute the operation. Binary operations will first pop the right operand, followed by the left. The operation result is pushed to the stack. The operation host, such as Int32Schema , must support the requested operation. Type schemas can declare support for operations using SupportsOperationHandler and PerformOperationHandler . This is a real instruction. It is recommended to use the alternative virtual instructions described in Arithmetic and Logical Operations for the sake of clarity. OPR < operationHostTypeIndex > , < operationId > MathAdd Pops two values off the stack and pushes their sum. This is a virtual instruction for Operation . ADD < operationHostTypeIndex > OPR < operationHostTypeIndex > , 1 MathSubtract Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their difference, \\(b - a\\) . This is a virtual instruction for Operation . SUB < operationHostTypeIndex > OPR < operationHostTypeIndex > , 2 MathMultiply Pops two values off the stack and pushes their product. This is a virtual instruction for Operation . MUL < operationHostTypeIndex > OPR < operationHostTypeIndex > , 3 MathDivide Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their quotient, \\(b / a\\) . This is a virtual instruction for Operation . DIV < operationHostTypeIndex > OPR < operationHostTypeIndex > , 4 MathModulus Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their remainder, \\(b \\bmod a\\) . This is a virtual instruction for Operation . MOD < operationHostTypeIndex > OPR < operationHostTypeIndex > , 5 MathNegate Pops a value \\(a\\) off the stack and pushes its negation, \\(-a\\) . This is a virtual instruction for Operation . NEG < operationHostTypeIndex > OPR < operationHostTypeIndex > , 16 LogicalAnd Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their logical AND, \\(a \\land b\\) . This is a virtual instruction for Operation . AND < operationHostTypeIndex > OPR < operationHostTypeIndex > , 6 LogicalOr Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their logical OR, \\(b \\lor a\\) . This is a virtual instruction for Operation . ORR < operationHostTypeIndex > OPR < operationHostTypeIndex > , 7 LogicalNot Pops a value \\(a\\) off the stack and pushes its logical negation, \\(\\lnot a\\) . This is a virtual instruction for Operation . NOT < operationHostTypeIndex > OPR < operationHostTypeIndex > , 15 RelationalEquals Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are equal, \\(b = a\\) . This is a virtual instruction for Operation . REQ < operationHostTypeIndex > OPR < operationHostTypeIndex > , 8 RelationalNotEquals Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are not equal, \\(b \\neq a\\) . This is a virtual instruction for Operation . RNE < operationHostTypeIndex > OPR < operationHostTypeIndex > , 9 RelationalLessThan Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether the result of \\(b \\lt a\\) . This is a virtual instruction for Operation . RLT < operationHostTypeIndex > OPR < operationHostTypeIndex > , 10 RelationalGreaterThan Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are not equal, \\(b \\gt a\\) . This is a virtual instruction for Operation . RGT < operationHostTypeIndex > OPR < operationHostTypeIndex > , 11 RelationalLessThanEquals Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are less than or equal, \\(b \\le a\\) . This is a virtual instruction for Operation . RLE < operationHostTypeIndex > OPR < operationHostTypeIndex > , 12 RelationalGreaterThanEquals Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are greater than or equal, \\(b \\ge a\\) . This is a virtual instruction for Operation . RGE < operationHostTypeIndex > OPR < operationHostTypeIndex > , 13 RelationalIs Pops two values, a then b , off the stack and pushes whether b is a . This is a virtual instruction for Operation , though it does not appear to be used anywhere. RIS < operationHostTypeIndex > OPR < operationHostTypeIndex > , 14 PostIncrement Pops a value \\(a\\) off the stack and pushes \\(a + 1\\) . This is a virtual instruction for Operation . INC < operationHostTypeIndex > OPR < operationHostTypeIndex > , 17 PostDecrement Pops a value \\(a\\) off the stack and pushes \\(a - 1\\) . This is a virtual instruction for Operation . DEC < operationHostTypeIndex > OPR < operationHostTypeIndex > , 18 Stack Manipulation PushNull Pushes a null value to the stack. PSHN PushConstant Pushes the specified constant to the stack. PSHC < constantIndex > PSHC @< constantName > PushThis Pushes the current markup instance, an IMarkupTypeBase , to the stack. PSHT DiscardValue Pops an object off the stack and does nothing. DIS Control Flow ReturnValue Returns the topmost item from the stack. RET ReturnVoid Returns from the script. RETV JumpIfFalse Pops a boolean value off the stack and jumps to the specified offset if false . JMPF < offset > JumpIfFalsePeek Peeks a boolean value from the top of the stack and jumps to the specified offset if false . JMPFP < offset > JumpIfTruePeek Peeks a boolean value from the top of the stack and jumps to the specified offset if true . JMPTP < offset > JumpIfDictionaryContains Jumps to the specified offset if a dictionary contains the specified key. Follows the same collection semantics as PropertyDictionaryAdd . JMPD < propertyIndex > , < keyConstantIndex > , < offset > JumpIfNullPeek Peeks a value off the stack and jumps to the specified offset if null . JMPNP < offset > Jump Unconditionally jumps to the specified offset. JMP < offset > Listeners ConstructListenerStorage TODO IStringEncodable So I added an interface named IStringEncodable that has what's essentially a specialized ToString() method. Each schema has a matching runtime type, and if the schema supports converting from a string, I modify the runtime class to implement IStringEncodable and returns a valid string that UIX already knows how to parse. It's a pretty manual process, so I've been implementing that interface as I observe incorrect constants in the disassembly. Turns out the Image schema supports string encoding, but UIImage (the corresponding runtime class) didn't implement IStringEncodable so it has the wrong representation in the disassembly.","title":"UIX Assembly"},{"location":"Zune%20software/Iris/uix-assembly/#uix-assembly","text":"","title":"UIX Assembly"},{"location":"Zune%20software/Iris/uix-assembly/#instruction-set","text":"","title":"Instruction Set"},{"location":"Zune%20software/Iris/uix-assembly/#summary","text":"","title":"Summary"},{"location":"Zune%20software/Iris/uix-assembly/#general","text":"Mneumonic Name COBJ ConstructObject COBJI ConstructObjectIndirect COBP ConstructObjectParam CSTR ConstructFromString CBIN ConstructFromBinary INIT InitializeInstance INITI InitializeInstanceIndirect LSYM LookupSymbol WSYM WriteSymbol WSYMP WriteSymbolPeek CSYM ClearSymbol PINI PropertyInitialize PINII PropertyInitializeIndirect PLAD PropertyListAdd PDAD PropertyDictionaryAdd PASS PropertyAssign PASST PropertyAssignStatic PGET PropertyGet PGETP PropertyGetPeek PGETT PropertyGetStatic MINV MethodInvoke MINVP MethodInvokePeek MINVT MethodInvokeStatic MINVA MethodInvokePushLastParam MINVAT MethodInvokeStaticPushLastParam VTC VerifyTypeCast CON ConvertType OPR Operation ISC IsCheck ASC As TYP TypeOf PSHN PushNull PSHC PushConstant PSHT PushThis DIS DiscardValue RET ReturnValue RETV ReturnVoid JMPF JumpIfFalse JMPFP JumpIfFalsePeek JMPTP JumpIfTruePeek JMPD JumpIfDictionaryContains JMPNP JumpIfNullPeek JMP Jump CLIS ConstructListenerStorage LIS Listen LISD DestructiveListen DBG EnterDebugState","title":"General"},{"location":"Zune%20software/Iris/uix-assembly/#math-operators","text":"Mneumonic Name ADD MathAdd SUB MathSubtract MUL MathMultiply DIV MathDivide MOD MathModulus NEG MathNegate AND LogicalAnd ORR LogicalOr NOT LogicalNot REQ RelationalEquals RNE RelationalNotEquals RLT RelationalLessThan RGT RelationalGreaterThan RLE RelationalLessThanEquals RGE RelationalGreaterThanEquals RIS RelationalIs INC PostIncrement DEC PostDecrement","title":"Math Operators"},{"location":"Zune%20software/Iris/uix-assembly/#object-instantiation","text":"This family of instructions calls the constructor for the given object. All variants take the index of the object type to construct.","title":"Object instantiation"},{"location":"Zune%20software/Iris/uix-assembly/#constructobject","text":"Calls the default constructor with no parameters. COBJ < typeIndex >","title":"ConstructObject"},{"location":"Zune%20software/Iris/uix-assembly/#constructobjectindirect","text":"Used to create 'wrappers' of another constructed object. It is used for type schemas that implement IDynamicConstructionSchema , which appears to only be used by UIClassTypeSchema for creating the root <UI> element. The assignment type is taken from the first operand, while the target type is popped off the stack. COBJI < assignmentTypeIndex >","title":"ConstructObjectIndirect"},{"location":"Zune%20software/Iris/uix-assembly/#constructobjectparam","text":"Calls the specified constructor with N parameters popped from the stack, with the N th parameter at the top of the stack. The number of parameters must match the constructor exactly. COBP < typeIndex > , < constructorIndex >","title":"ConstructObjectParam"},{"location":"Zune%20software/Iris/uix-assembly/#constructfromstring","text":"Uses the target's type converter to construct an instance from a constant string. CSTR < typeIndex > , < stringIndex >","title":"ConstructFromString"},{"location":"Zune%20software/Iris/uix-assembly/#constructfrombinary","text":"Uses the target type's binary decoder to construct an instance from a binary blob. The blob is stored inline and can be any length. The binary decoder is responsible for determining the length and consuming the entire blob.","title":"ConstructFromBinary"},{"location":"Zune%20software/Iris/uix-assembly/#initializeinstance","text":"Pops an object from the stack and initializes it using the specified type schema. This instruction is required to initialize UIClass and Class objects immediately after construction. INIT < typeIndex >","title":"InitializeInstance"},{"location":"Zune%20software/Iris/uix-assembly/#initializeinstanceindirect","text":"Identical to InitializeInstance , except the type schema is popped off the stack rather than indexed from the type imports table. INITI","title":"InitializeInstanceIndirect"},{"location":"Zune%20software/Iris/uix-assembly/#symbols","text":"This family of instructions manages symbols, usually local variables.","title":"Symbols"},{"location":"Zune%20software/Iris/uix-assembly/#lookupsymbol","text":"Looks up a symbol in the symbol reference table and pushes its value to the stack. LSYM < symbolReferenceIndex >","title":"LookupSymbol"},{"location":"Zune%20software/Iris/uix-assembly/#writesymbol","text":"Writes a value popped from the stack to the specified symbol in the symbol reference table. WSYM < symbolReferenceIndex >","title":"WriteSymbol"},{"location":"Zune%20software/Iris/uix-assembly/#writesymbolpeek","text":"Identical to WriteSymbol , except the value to be written is peeked instead of popped off the stack. WSYMP < symbolReferenceIndex >","title":"WriteSymbolPeek"},{"location":"Zune%20software/Iris/uix-assembly/#clearsymbol","text":"If the specified symbol is a scoped local, it is undeclared. Otherwise, this instruction is a no-op. CSYM < symbolReferenceIndex >","title":"ClearSymbol"},{"location":"Zune%20software/Iris/uix-assembly/#properties","text":"","title":"Properties"},{"location":"Zune%20software/Iris/uix-assembly/#propertyinitialize","text":"Pops a value from the stack and initializes the specified property on the current instance, also popped from the stack. PINI < propertyIndex >","title":"PropertyInitialize"},{"location":"Zune%20software/Iris/uix-assembly/#propertyinitializeindirect","text":"Simimlar to PropertyInitialize , except the parent type schema is popped from the stack. PINII < propertyIndex >","title":"PropertyInitializeIndirect"},{"location":"Zune%20software/Iris/uix-assembly/#propertylistadd","text":"Pops a value from the stack and appends it to the end of a list. The key is read from the constants table. The target object is peeked from the stack. If propertyIndex is 0xFFFF , the target object is the list itself. Otherwise, the list is read from the specified property on the target object. PLAD < propertyIndex > // target.Property.Add(value) PLAD 0xFFFF // target.Add(value)","title":"PropertyListAdd"},{"location":"Zune%20software/Iris/uix-assembly/#propertydictionaryadd","text":"Pops a value from the stack and assigns it to the given key in a dictionary. The same semantics from PropertyListAdd regarding propretyIndex apply. PDAD < propertyIndex > , < keyConstantIndex > // target.Property[value] = value PDAD 0xFFFF , < keyConstantIndex > // target[key] = value","title":"PropertyDictionaryAdd"},{"location":"Zune%20software/Iris/uix-assembly/#propertyassign","text":"Assigns a value to the specified property. The target object is popped from the stack before the value is peeked. PASS < propertyIndex > ; object.Property = value","title":"PropertyAssign"},{"location":"Zune%20software/Iris/uix-assembly/#propertyassignstatic","text":"Peeks a value from the stack and assigns it to the specified static property. PASST < propertyIndex > ; StaticInstance.Property = value","title":"PropertyAssignStatic"},{"location":"Zune%20software/Iris/uix-assembly/#propertyget","text":"Pops a parent object from the stack and pushes the value of the specified property. PGET < propertyIndex > ; object.Property","title":"PropertyGet"},{"location":"Zune%20software/Iris/uix-assembly/#propertygetpeek","text":"Peeks an object from the stack and pushes the value of the specified property. PGETP < propertyIndex > ; object.Property","title":"PropertyGetPeek"},{"location":"Zune%20software/Iris/uix-assembly/#propertygetstatic","text":"Pushes the value of the specified static property to the stack. PGETT < propertyIndex > ; StaticInstance.Property","title":"PropertyGetStatic"},{"location":"Zune%20software/Iris/uix-assembly/#methods","text":"","title":"Methods"},{"location":"Zune%20software/Iris/uix-assembly/#methodinvoke","text":"Invokes the specified method with N parameters popped from the stack, with the N th parameter at the top of the stack. The number of parameters must match the method signature exactly. The parent object is popped from the stack. If the method has a return value, it is pushed to the stack. MINV < methodIndex >","title":"MethodInvoke"},{"location":"Zune%20software/Iris/uix-assembly/#methodinvokepeek","text":"Identical to MethodInvoke , except the parent object is peeked instead of popped from the stack. MINVP < methodIndex >","title":"MethodInvokePeek"},{"location":"Zune%20software/Iris/uix-assembly/#methodinvokestatic","text":"Identical to MethodInvoke , except the method must be static and no parent object is popped from the stack. MINVT < methodIndex >","title":"MethodInvokeStatic"},{"location":"Zune%20software/Iris/uix-assembly/#methodinvokepushlastparam","text":"Similar to MethodInvoke , except the last parameter is pushed to the stack. When this mode is used, the method return value is not pushed to the stack. MINVA < methodIndex >","title":"MethodInvokePushLastParam"},{"location":"Zune%20software/Iris/uix-assembly/#methodinvokestaticpushlastparam","text":"Similar to MethodInvokeStatic , except the last parameter is pushed to the stack. When this mode is used, the method return value is not pushed to the stack. Equivalent to MethodInvokePushLastParam but for static methods. MINVAT < methodIndex >","title":"MethodInvokeStaticPushLastParam"},{"location":"Zune%20software/Iris/uix-assembly/#type-manipulation","text":"This family of instructions performs operations that manipulate types.","title":"Type Manipulation"},{"location":"Zune%20software/Iris/uix-assembly/#verifytypecast","text":"Throws a script runtime error if the object at the top of the stack cannot be cast to the specified type. VTC < propertyIndex >","title":"VerifyTypeCast"},{"location":"Zune%20software/Iris/uix-assembly/#converttype","text":"Pops an object from the stack and converts from one specified type to another. The converted object is pushed to the stack. Note that this is not equivalent to a simple cast: see As . CON < toTypeIndex > , < fromTypeIndex >","title":"ConvertType"},{"location":"Zune%20software/Iris/uix-assembly/#ischeck","text":"Pops an object from the stack and checks whether it is an instance of the specified type. The check result is pushed as a bool to the stack. Returns false is the object is null . ISC < typeIndex >","title":"IsCheck"},{"location":"Zune%20software/Iris/uix-assembly/#as","text":"If the object at the top of the stack is assignable to the specified type, no action is taken. Otherwise, the object is replaced with null . ASC < typeIndex >","title":"As"},{"location":"Zune%20software/Iris/uix-assembly/#typeof","text":"Pushes the schema of the specified type to the stack. TYP < typeIndex >","title":"TypeOf"},{"location":"Zune%20software/Iris/uix-assembly/#arithmetic-and-logical-operations","text":"","title":"Arithmetic and Logical Operations"},{"location":"Zune%20software/Iris/uix-assembly/#operation","text":"Performs the specified arithmetic or logical operation using the provided operation host type schema. Unary operations will pop a single value off the stack and execute the operation. Binary operations will first pop the right operand, followed by the left. The operation result is pushed to the stack. The operation host, such as Int32Schema , must support the requested operation. Type schemas can declare support for operations using SupportsOperationHandler and PerformOperationHandler . This is a real instruction. It is recommended to use the alternative virtual instructions described in Arithmetic and Logical Operations for the sake of clarity. OPR < operationHostTypeIndex > , < operationId >","title":"Operation"},{"location":"Zune%20software/Iris/uix-assembly/#mathadd","text":"Pops two values off the stack and pushes their sum. This is a virtual instruction for Operation . ADD < operationHostTypeIndex > OPR < operationHostTypeIndex > , 1","title":"MathAdd"},{"location":"Zune%20software/Iris/uix-assembly/#mathsubtract","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their difference, \\(b - a\\) . This is a virtual instruction for Operation . SUB < operationHostTypeIndex > OPR < operationHostTypeIndex > , 2","title":"MathSubtract"},{"location":"Zune%20software/Iris/uix-assembly/#mathmultiply","text":"Pops two values off the stack and pushes their product. This is a virtual instruction for Operation . MUL < operationHostTypeIndex > OPR < operationHostTypeIndex > , 3","title":"MathMultiply"},{"location":"Zune%20software/Iris/uix-assembly/#mathdivide","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their quotient, \\(b / a\\) . This is a virtual instruction for Operation . DIV < operationHostTypeIndex > OPR < operationHostTypeIndex > , 4","title":"MathDivide"},{"location":"Zune%20software/Iris/uix-assembly/#mathmodulus","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their remainder, \\(b \\bmod a\\) . This is a virtual instruction for Operation . MOD < operationHostTypeIndex > OPR < operationHostTypeIndex > , 5","title":"MathModulus"},{"location":"Zune%20software/Iris/uix-assembly/#mathnegate","text":"Pops a value \\(a\\) off the stack and pushes its negation, \\(-a\\) . This is a virtual instruction for Operation . NEG < operationHostTypeIndex > OPR < operationHostTypeIndex > , 16","title":"MathNegate"},{"location":"Zune%20software/Iris/uix-assembly/#logicaland","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their logical AND, \\(a \\land b\\) . This is a virtual instruction for Operation . AND < operationHostTypeIndex > OPR < operationHostTypeIndex > , 6","title":"LogicalAnd"},{"location":"Zune%20software/Iris/uix-assembly/#logicalor","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes their logical OR, \\(b \\lor a\\) . This is a virtual instruction for Operation . ORR < operationHostTypeIndex > OPR < operationHostTypeIndex > , 7","title":"LogicalOr"},{"location":"Zune%20software/Iris/uix-assembly/#logicalnot","text":"Pops a value \\(a\\) off the stack and pushes its logical negation, \\(\\lnot a\\) . This is a virtual instruction for Operation . NOT < operationHostTypeIndex > OPR < operationHostTypeIndex > , 15","title":"LogicalNot"},{"location":"Zune%20software/Iris/uix-assembly/#relationalequals","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are equal, \\(b = a\\) . This is a virtual instruction for Operation . REQ < operationHostTypeIndex > OPR < operationHostTypeIndex > , 8","title":"RelationalEquals"},{"location":"Zune%20software/Iris/uix-assembly/#relationalnotequals","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are not equal, \\(b \\neq a\\) . This is a virtual instruction for Operation . RNE < operationHostTypeIndex > OPR < operationHostTypeIndex > , 9","title":"RelationalNotEquals"},{"location":"Zune%20software/Iris/uix-assembly/#relationallessthan","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether the result of \\(b \\lt a\\) . This is a virtual instruction for Operation . RLT < operationHostTypeIndex > OPR < operationHostTypeIndex > , 10","title":"RelationalLessThan"},{"location":"Zune%20software/Iris/uix-assembly/#relationalgreaterthan","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are not equal, \\(b \\gt a\\) . This is a virtual instruction for Operation . RGT < operationHostTypeIndex > OPR < operationHostTypeIndex > , 11","title":"RelationalGreaterThan"},{"location":"Zune%20software/Iris/uix-assembly/#relationallessthanequals","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are less than or equal, \\(b \\le a\\) . This is a virtual instruction for Operation . RLE < operationHostTypeIndex > OPR < operationHostTypeIndex > , 12","title":"RelationalLessThanEquals"},{"location":"Zune%20software/Iris/uix-assembly/#relationalgreaterthanequals","text":"Pops two values, \\(a\\) then \\(b\\) , off the stack and pushes whether they are greater than or equal, \\(b \\ge a\\) . This is a virtual instruction for Operation . RGE < operationHostTypeIndex > OPR < operationHostTypeIndex > , 13","title":"RelationalGreaterThanEquals"},{"location":"Zune%20software/Iris/uix-assembly/#relationalis","text":"Pops two values, a then b , off the stack and pushes whether b is a . This is a virtual instruction for Operation , though it does not appear to be used anywhere. RIS < operationHostTypeIndex > OPR < operationHostTypeIndex > , 14","title":"RelationalIs"},{"location":"Zune%20software/Iris/uix-assembly/#postincrement","text":"Pops a value \\(a\\) off the stack and pushes \\(a + 1\\) . This is a virtual instruction for Operation . INC < operationHostTypeIndex > OPR < operationHostTypeIndex > , 17","title":"PostIncrement"},{"location":"Zune%20software/Iris/uix-assembly/#postdecrement","text":"Pops a value \\(a\\) off the stack and pushes \\(a - 1\\) . This is a virtual instruction for Operation . DEC < operationHostTypeIndex > OPR < operationHostTypeIndex > , 18","title":"PostDecrement"},{"location":"Zune%20software/Iris/uix-assembly/#stack-manipulation","text":"","title":"Stack Manipulation"},{"location":"Zune%20software/Iris/uix-assembly/#pushnull","text":"Pushes a null value to the stack. PSHN","title":"PushNull"},{"location":"Zune%20software/Iris/uix-assembly/#pushconstant","text":"Pushes the specified constant to the stack. PSHC < constantIndex > PSHC @< constantName >","title":"PushConstant"},{"location":"Zune%20software/Iris/uix-assembly/#pushthis","text":"Pushes the current markup instance, an IMarkupTypeBase , to the stack. PSHT","title":"PushThis"},{"location":"Zune%20software/Iris/uix-assembly/#discardvalue","text":"Pops an object off the stack and does nothing. DIS","title":"DiscardValue"},{"location":"Zune%20software/Iris/uix-assembly/#control-flow","text":"","title":"Control Flow"},{"location":"Zune%20software/Iris/uix-assembly/#returnvalue","text":"Returns the topmost item from the stack. RET","title":"ReturnValue"},{"location":"Zune%20software/Iris/uix-assembly/#returnvoid","text":"Returns from the script. RETV","title":"ReturnVoid"},{"location":"Zune%20software/Iris/uix-assembly/#jumpiffalse","text":"Pops a boolean value off the stack and jumps to the specified offset if false . JMPF < offset >","title":"JumpIfFalse"},{"location":"Zune%20software/Iris/uix-assembly/#jumpiffalsepeek","text":"Peeks a boolean value from the top of the stack and jumps to the specified offset if false . JMPFP < offset >","title":"JumpIfFalsePeek"},{"location":"Zune%20software/Iris/uix-assembly/#jumpiftruepeek","text":"Peeks a boolean value from the top of the stack and jumps to the specified offset if true . JMPTP < offset >","title":"JumpIfTruePeek"},{"location":"Zune%20software/Iris/uix-assembly/#jumpifdictionarycontains","text":"Jumps to the specified offset if a dictionary contains the specified key. Follows the same collection semantics as PropertyDictionaryAdd . JMPD < propertyIndex > , < keyConstantIndex > , < offset >","title":"JumpIfDictionaryContains"},{"location":"Zune%20software/Iris/uix-assembly/#jumpifnullpeek","text":"Peeks a value off the stack and jumps to the specified offset if null . JMPNP < offset >","title":"JumpIfNullPeek"},{"location":"Zune%20software/Iris/uix-assembly/#jump","text":"Unconditionally jumps to the specified offset. JMP < offset >","title":"Jump"},{"location":"Zune%20software/Iris/uix-assembly/#listeners","text":"","title":"Listeners"},{"location":"Zune%20software/Iris/uix-assembly/#constructlistenerstorage","text":"","title":"ConstructListenerStorage"},{"location":"Zune%20software/Iris/uix-assembly/#todo","text":"","title":"TODO"},{"location":"Zune%20software/Iris/uix-assembly/#istringencodable","text":"So I added an interface named IStringEncodable that has what's essentially a specialized ToString() method. Each schema has a matching runtime type, and if the schema supports converting from a string, I modify the runtime class to implement IStringEncodable and returns a valid string that UIX already knows how to parse. It's a pretty manual process, so I've been implementing that interface as I observe incorrect constants in the disassembly. Turns out the Image schema supports string encoding, but UIImage (the corresponding runtime class) didn't implement IStringEncodable so it has the wrong representation in the disassembly.","title":"IStringEncodable"}]}